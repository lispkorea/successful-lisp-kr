<!DOCTYPE HTML>
<html lang="kr" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>레슨 10. 프리뷰 - 다른 데이터 타입 - Successful Lisp - 한국어판</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="Successful Lisp">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../Index.html">들어가며</a></li><li class="chapter-item expanded affix "><li class="part-title">03. 12개의 레슨으로 배우는 필수 리스프</li><li class="chapter-item expanded "><a href="../ch03/ch03.html">03. 12개의 레슨으로 배우는 필수 리스프</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ch03/lesson_01.html">레슨 01. 필수 - 신택스</a></li><li class="chapter-item expanded "><a href="../ch03/lesson_02.html">레슨 02. 필수 - 평가</a></li><li class="chapter-item expanded "><a href="../ch03/lesson_03.html">레슨 03. 스페셜 폼과 매크로에 대한 예제</a></li><li class="chapter-item expanded "><a href="../ch03/lesson_04.html">레슨 04. 조립과 분해</a></li><li class="chapter-item expanded "><a href="../ch03/lesson_05.html">레슨 05. 네이밍과 아이덴티티</a></li><li class="chapter-item expanded "><a href="../ch03/lesson_06.html">레슨 06. 바인딩 vs 할당</a></li><li class="chapter-item expanded "><a href="../ch03/lesson_07.html">레슨 07. 필수 - 함수 정의</a></li><li class="chapter-item expanded "><a href="../ch03/lesson_08.html">레슨 08. 필수 - 매크로 정의</a></li><li class="chapter-item expanded "><a href="../ch03/lesson_09.html">레슨 09. 필수 - 다중 값</a></li><li class="chapter-item expanded "><a href="../ch03/lesson_10.html" class="active">레슨 10. 프리뷰 - 다른 데이터 타입</a></li><li class="chapter-item expanded "><a href="../ch03/lesson_11.html">레슨 11. 필수 - 입력과 출력</a></li><li class="chapter-item expanded "><a href="../ch03/lesson_12.html">레슨 12. 필수 - 리더 매크로</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Successful Lisp - 한국어판</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/lispkorea/successful-lisp-kr" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/lispkorea/successful-lisp-kr/edit/main/src/ch03/lesson_10.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="레슨-10-프리뷰---다른-데이터-타입a-preview-of-other-data-type"><a class="header" href="#레슨-10-프리뷰---다른-데이터-타입a-preview-of-other-data-type">레슨 10. 프리뷰 - 다른 데이터 타입(A Preview of Other Data Type)</a></h1>
<ul>
<li><a href="https://dept-info.labri.fr/~strandh/Teaching/MTP/Common/David-Lamkins/chapter03-10.html">원문</a></li>
</ul>
<h2 id="lisp-almost-always-does-the-right-thing-with-numbers"><a class="header" href="#lisp-almost-always-does-the-right-thing-with-numbers">Lisp almost always does the right thing with numbers</a></h2>
<p>이는 말하기에 이상한 것처럼 들립니다. 컴퓨터는 항상 숫자로 일을 수행하지 않나요?  음, 아니요... 보통은 그렇지 않습니다.</p>
<p>수치 계산은 수많은 방식으로 나뉠 수 있습니다. 가장 큰 문제가 되는 점 중 하나는 소수의 계산이 있습니다 (여러분의 언어가 이를 실수라 부른다면, 그것은 거짓말 입니다). visual-어쩌고 혹은 객체-지향의-무언가에 대한 많은 책들중 거의 절반정도가 소수의 계산의 적절한 사용에 대해 쓰여졌습니다.</p>
<p>소수의 문제는 수학적으로 실수가 아니지만, 종종 그것인양 (잘못)사용됩니다.
중요한 문제는 그러한 소수가 정확도의 한계를 지녔다는 것입니다 - only so many digits to the right of the decimal point. 이제, 계산의 모든 숫자가 거의 같은 규모라면, 계산은 정확도를 잃지 않을 것입니다. 그러나, 숫자가 매우 다양한 규모라면, 소수 계산은 정확도를 희생합니다.</p>
<p>여러분의 컴퓨터의 소수가 정확하게 소숫점 7자리를 표현할수 있다고 가정해 봅시다. 그러면, 여러분은 1897482.0에 2973225.0를 더하여 완벽히 정확한 답을 얻을 수 있을 것입니다. 그러나, 1897482.0에 0.2973225를 더하고자 한다면, 정확한 답은 14자리의 숫자이지만, 여러분의 컴퓨터는 1897482.0을 답으로 할 것입니다.</p>
<p>소수에 간한 또다른 문제는 더욱 미묘subtle합니다. 프로그램을 작성할때, 10진수에 기반하여 수를 쓸 것입니다. 그러나 컴퓨터는 모든 연산을 2진수에 기반하여 수행합니다. 10진수에서 2진수로의 변환은 &quot;명백히 정확한&quot; 특정 숫자에 대해 재미난 일을 수행합니다. 예를들어, 소수 0.1은 2진수로 변환하면 순환 분수입니다. 컴퓨터는 순환분수에 의해 요구되는 무한한 숫자를 저장하지 못하기에, 정확하게 0.1을 저장할 수 없습니다.</p>
<p>대부분의 컴퓨터 언어에서 정수(자연수) 연산은 또다른 문제를 지닙니다</p>
<ul>
<li>하나의 정수를 담을 수 있는 양수나 음수의 최대치에 재한을 가하는 경향이 있습니다. 따라서, 숫자 하나를 여러분의 언어에 대해 컴퓨터를 다룰 수 있는 가장 큰 정수에 더하고자 한다면, 둘 중 하나가 발생합니다:</li>
</ul>
<ol>
<li>에러로 프로그램이 종료된다, 혹은</li>
<li>굉장히 부정확한 답을 얻는다.(가장 큰 양수에 1을 더한 것은 가장 큰 음수중에 적어도 하나를 만들어 냅니다.)</li>
</ol>
<p>그러면 숫자에 관해 올바른 일을 수행하기 위해 리스프는 어떻게 처리할까요? 무엇보다도, 이 문제가 컴퓨터 연산에서 나온 것처럼 보입니다. 답은 리스프는 내장 컴퓨터 산술 연산을 바로 사용하지 않는다는 것입니다 - 수학적으로 정확한 특정한 수치 데이터 형식을 추가하였습니다:</p>
<ul>
<li>bignums은 무한한 정수이다 (컴퓨터의 메모리의 한계에 달려있다)</li>
<li>유리수는, 대략적인 머신 나눗셈 알고리즘에서 나온 결과인 소수가 아니라,</li>
</ul>
<p>두 정수의 정확한 몫이다.</p>
<p>물론, 리스프 또한 machine-기반 정수와 소수를 지닙니다. Machine integers를 리스프에서 fixnums라 부릅니다. fixnum의 범위에서 자연수가 떨어지면, 리스프는 이를 machine integer로 저장할 것입니다. 그러나, 이게 매우 커지면, 리스프는 자동으로 이를 bignum으로 승격promote시킵니다.</p>
<p>제가 리스프는 거의 항상 수에 관해 올바른 일을 수행한다고 했을때, 저는 이것이 거의 항상 수학적으로 옳은 수의 표현을 고른다는 것을 의미한다는 뜻으로 말했었습니다:</p>
<pre><code class="language-lisp">(/ 1 3)
;;=&gt; 1/3

(+ (/ 7 11) (/ 13 31))
;;=&gt; 360/341

(defun factorial (n)
  (cond ((= n 0) 1)
        (t (* n (factorial (- n 1))))))
;;=&gt; FACTORIAL

(factorial 100)
;;=&gt; 933262154439441526816992388562667004907159682643816214685
     929638952175999932299156089414639761565182862536979208272
     23758251185210916864000000000000000000000000
</code></pre>
<p>소수를 이용한 계산을 작성할 수 있지만, 리스프는 정확한 수치 결과를 부정확한 소수로 전환할수 없기에(여러분은 이에게 소수는 전염된다라고 말해야 합니다) 일단 이를 계산에 도입하면, 전체 계산 결과는 소수를 유지할 것입니다:</p>
<pre><code class="language-lisp">
(float (/ 1 3))
;;=&gt; 0.3333333333333333

(* (float (/ 1 10)) 
   (float (/ 1 10)))
;;=&gt; 0.010000000000000002

(+ 1/100 (* (float (/ 1 10))
            (float (/ 1 10))))
;;=&gt; 0.020000000000000004

(+ 1/100 1/100) ; 이전 계산과 비교하세요
;;=&gt; 1/50

(* 3 7 10.0)
;;=&gt; 210.0

(- 1.0 1)
;;=&gt; 0.0

(+ 1/3 2/3 0.0)
;;=&gt; 1.0

(+ 1/3 2/3)
;;=&gt; 1 ; 이전 계산과 비교하세요
</code></pre>
<p>리스프는 소수를 소수점과 같이, 정수에는 없이 출력합니다.</p>
<h2 id="characters-give-lisp-something-to-read-and-write"><a class="header" href="#characters-give-lisp-something-to-read-and-write">Characters give Lisp something to read and write</a></h2>
<p>기본적으로 리스프 I/O는 문자를 이용합니다. READ와 WRITE 함수는 문자를 리스프 오브젝트로 그리고 역으로 변환시킵니다. READ-CHAR와 WRITE_CHAR는 단일 문자를 읽고 씁니다.</p>
<pre><code class="language-lisp">(read)
;;&lt;&lt; a \newline
;;=&gt; A

(read)
;;&lt;&lt; #\a \newline
;;=&gt; a

(read-char)
;;&lt;&lt; a
;;=&gt; #\a

(write 'a)
;;&gt;&gt; A
;;=&gt; A

(write #\a)
;;&gt;&gt; #\a
;;=&gt; #\a

(write-char #\a)
;;&gt;&gt; a
;;=&gt; #\a

(write-char 'a)
| Error: Not a character
</code></pre>
<p>위 예에서 새로운 표기를 추가했습니다. <code>;;&lt;&lt;</code> 표시는 리스프는 READ와 같은 입력함수에 대한 입력을 기다린다는 것을 의미합니다. <code>\newline</code>은 엔터(enter)키에 의해 생성되는 개행문자를 나타냅니다.</p>
<p><code>;;&gt;&gt;</code>는 값을 반환하는 것(<code>;;=&gt;</code>)이 아니라 출력을 나타냅니다.</p>
<p>개행시 <code>read</code>의 입력받는 동작이 종료된다는 것을 알아채셨을 것입니다. READ는 완벽한 리스프 표현식을 구성하고자하는 문자들을 모으기 때문입니다. 레슨 11[p 77]에서 이것에 대해 좀 더 살펴볼 것입니다. 이번 예제에서, READ는 새로운라인newline으로 종료되는 심볼을 모읍니다. 심볼은 또한 공백, 괄호, 심볼의 일부가 아닌 문자로 종료됩니다.</p>
<p>대조적으로, READ-CHAR는 input에서 정확히 하나의 문자만 읽습니다. 문자를 받자마자, READ-CHAR는 실행을 완료하고 문자를 반환합니다.</p>
<p>몇몇 리스프 시스템은 어떠한 입력을 받아들이기 전에 return 키를 누르도록 요구할 것입니다. 이는 일상적인게 아니며, 환경설정 인자로 수정할 수 있습니다 - 여러분의 리스프 vender와 상담을 하시기 바랍니다.</p>
<p>WRITE와 WRITE-CHAR는 둘다 받았던 값을 반환합니다. 값을 출력하는 방식은 다릅니다. WRITE는 값을 출력하므로, 동일한 값을 생성하는 READ로 표현할 수 있습니다. WRITE-CHAR는, 이것이 READ에서의 문자라는 것을 나타내는 추가 리스프 syntax (#)가 없는, 읽을 수 있는 문자를 출력합니다.</p>
<p>리스프는 단일 문자를 #\문자 표기법을 이용하여 나타내며, 그러한 문자로는 literal 문자나 출력가능한 상형문자가 아닌 문자의 이름이 있습니다.</p>
<div class="table-wrapper"><table><thead><tr><th>Character</th><th>Hex Value</th><th>Lisp</th><th>Standard?</th></tr></thead><tbody>
<tr><td>space</td><td>20</td><td>#\Space</td><td>yes</td></tr>
<tr><td>newline</td><td>--</td><td>#\Newline</td><td>yes</td></tr>
<tr><td>backspace</td><td>08</td><td>#\Backspace</td><td>semi</td></tr>
<tr><td>tab</td><td>09</td><td>#\Tab</td><td>semi</td></tr>
<tr><td>linefeed</td><td>0A</td><td>#\Linefeed</td><td>semi</td></tr>
<tr><td>formfeed</td><td>0C</td><td>#\Page</td><td>semi</td></tr>
<tr><td>carriage return</td><td>0D</td><td>#\Return</td><td>semi</td></tr>
<tr><td>rubout or DEL</td><td>7F</td><td>#\Rubout</td><td>semi</td></tr>
</tbody></table>
</div>
<p><code>#\Space</code>와 <code>#\Newline</code>만이 모든 리스프 시스템에서의 요구사항입니다. ASCII 문자셋를 이용하는 시스템은 아마 위에 나온 나머지 문자코드를 구현할 것입니다. #Newline 문자는 호스트 시스템에 맞는 출력 라인의 끝을 표시하는 convention을 따릅니다. 예로:</p>
<div class="table-wrapper"><table><thead><tr><th>System</th><th>Newline</th><th>Hex Value</th></tr></thead><tbody>
<tr><td>Macintosh</td><td>CR</td><td>0D</td></tr>
<tr><td>MS-DOS</td><td>CR LF</td><td>0D 0A</td></tr>
<tr><td>Unix</td><td>LF</td><td>0A</td></tr>
</tbody></table>
</div>
<p>94개의 출력가능한 표준 문자들이 <code>\#char</code>로 표현됩니다:</p>
<pre><code class="language-txt">  ! &quot; # $ % &amp; ' ( ) * + , - . /
0 1 2 3 4 5 6 7 8 9 : ; &lt; = &gt; ?
@ A B C D E F G H I J K L M N O
P Q R S T U V W X Y Z [ \ ] ^ _
‘ a b c d e f g h i j k l m n o
p q r s t u v w x y z { | } ~
</code></pre>
<h2 id="arrays-organize-data-into-tables"><a class="header" href="#arrays-organize-data-into-tables">Arrays organize data into tables</a></h2>
<p>여러분이 데이터를 2, 3, 더 많은 규모의 테이블에 역으려한다면, 배열array을 만들 수 있습니다:</p>
<pre><code class="language-lisp">(setq a1 (make-array '(3 4)))
;;=&gt; #2A((NIL NIL NIL NIL)
         (NIL NIL NIL NIL)
         (NIL NIL NIL NIL))

(setf (aref a1 0 0) (list 'element 0 0))
;;=&gt; (ELEMENT 0 0)

(setf (aref a1 1 0) (list 'element 1 0))
;;=&gt; (ELEMENT 1 0)

(setf (aref a1 2 0) (list 'element 2 0))
;;=&gt; (ELEMENT 2 0)

a1
;;=&gt; #2A(((ELEMENT 0 0) NIL NIL NIL)
         ((ELEMENT 1 0) NIL NIL NIL)
         ((ELEMENT 2 0) NIL NIL NIL))

(aref a1 0 0)
;;=&gt; (ELEMENT 0 0)

(setf (aref a1 0 1) pi)
;;=&gt; 3.141592653589793

(setf (aref a1 0 2) &quot;hello&quot;)
;;=&gt; &quot;hello&quot;

(aref a1 0 2)
;;=&gt; &quot;hello&quot;
</code></pre>
<p>dimensions의 리스트를 취하여 배열을 반환하는 MAKE-ARRAY를 이용하여 배열을 만듭니다. 기본적으로,  배열은 어떠한 종류의 데이터라도 담을 수 있습니다; 효율성을 위해 추가 인자로 데이터형식의 요소를 제한할 수 있습니다.</p>
<p>배열의 rank는 dimension의 수와 동일합니다. 위 예제에서 저희는 2-차원rank-2 배열을 만들었습니다. 리스프는 <code>#rankA(...)</code>표기법을 이용하여 배열을 출력합니다. 배열의 내용물은, 첫번째 dimension이 최상단 그룹의 요소로 보여지고, 마지막 dimension이 최하단 그룹의 요소로 보여지는, 중첩된 list로 보여집니다.</p>
<p>여러분의 리스프 시스템은 아마도 여기서 보여졌던것 처럼 라인을 넘기면서 배열을 출력하지 않을 것입니다. 저는 배열의 구조를 강조하기 위해 라인을 넘겼습니다.</p>
<p>배열의 요소를 받기 위해선, AREF를 이용합니다. AREF의 첫번째 요소는 배열입니다; 나머지 요소는 각 dimension의 index를 지정합니다. index의 수는 배열의 rank와 맞아야만 합니다.</p>
<p>배열의 요소를 설정하기 위해선, 이 예제에서 보인것 처럼 SETF form내부에서 AREF를 사용합니다. SETF는 SETQ와 유사하지만, SETQ가 값을 심볼에게 할당하고, SETF는 값을 place에 할당합니다. 예제에서 AREF 폼은 배열의 요소의 place를 지정합니다.</p>
<h2 id="백터는-일차원-배열"><a class="header" href="#백터는-일차원-배열">백터는 일차원 배열</a></h2>
<p>Vector는 일-차원one-dimensional 배열입니다. MAKE-ARRAY를 이용하여 벡터를 만들 수 있으며, AREF를 이용하여 이의 요소에 접근 할 수 있습니다.</p>
<pre><code class="language-lisp">(setq v1 (make-array '(3)))
;;=&gt; #(NIL NIL NIL)

(make-array 3)
;;=&gt; #(NIL NIL NIL)

(setf (aref v1 0) :zero)
;;=&gt; :ZERO

(setf (aref v1 1) :one)
;;=&gt; :ONE

(aref v1 0)
;;=&gt; :ZERO

v1
;;=&gt; #(:ZERO :ONE NIL)


;; 리스프는 #1A(...)이 아닌 조금 간소화된 form #(...)을 이용하여 벡터를 출력합니다.
;; MAKE-ARRAY에서 단일-원소 리스트나 벡터의 차원dimenion을 지정할 수 있습니다.
;; VECTOR 폼을 이용하여 값을 나열하여 벡터를 만들 수 있습니다:
(vector 34 22 30)
;;=&gt; #(34 22 30)
</code></pre>
<p>결과값이 list가 아닌 vector라는 점을 제외하면, 이는 LIST form과 유사합니다. list와 vector간에는 또 다른 닮음이 있습니다: 모두 sequence입니다. sequence는 13장[p 150]에서 보게될 함수에 의해 다뤄집니다.</p>
<p>벡터의 요소에 접근하기 위해 AREF를 이용하거나, sequence-특화 함수 ELT를 이용할 수 있습니다:</p>
<pre><code class="language-lisp">(setf v2 (vector 34 22 30 99 66 77))
;;=&gt; #(34 22 30 99 66 77)

(setf (elt v2 3) :radio)
;;=&gt; :RADIO

v2
;;=&gt; #(34 22 30 :RADIO 66 77)
</code></pre>
<h2 id="문자열은-문자를-담고있는-백터"><a class="header" href="#문자열은-문자를-담고있는-백터">문자열은 문자를 담고있는 백터</a></h2>
<p>여러분은 이미 &quot;...&quot; 신택스를 이용하여 문자열(string)을 작성하는 법을 알고 있습니다. 문자열은 벡터이기에, 문자열의 요소에 접근하기 위해 배열과 백터 함수를 적용할 수 있습니다. 또한 <code>make-string</code> 함수를 이용하여 문자열을 만들거나, <code>string</code> 함수를 이용하여 문자나 심볼을 문자열로 바꿀 수 있습니다.</p>
<pre><code class="language-lisp">(setq s1 &quot;hello, there.&quot;)
;;=&gt; &quot;hello, there.&quot;

(setf (elt s1 0) #\H))
;;=&gt; #\H

(setf (elt s1 12) #\!)
;;=&gt; #\!

s1
;;=&gt; &quot;Hello, there!&quot;

(string 'a-symbol)
;;=&gt; &quot;A-SYMBOL&quot;

(string #\G)
;;=&gt; &quot;G&quot;
</code></pre>
<h2 id="symbols-are-unique-but-they-have-many-values"><a class="header" href="#symbols-are-unique-but-they-have-many-values">Symbols are unique, but they have many values</a></h2>
<p>레슨 5에서 심볼은 고유한 독자성identity을 지닌다고 보았지만, 이는 반복성을 지닙니다: 심볼은 같은 철자의 다른 symbol과 동일합니다(이번 레슨 끝부분에서 좀더 배우게될 package designation를 포함하여). 이는 Lisp로 하여금 프로그램이나 데이터를 읽어올 수 있게 만들 수 있다는 것을 의미하며, 같은 철자로 나타낸 모든 심볼은 동일한 심볼입니다. 리스프가 이를 수행하는 매커니즘을 제공하기에, symbolic 정보를 다루는 프로그램을 작성하는 것에 대한 걱정을 하나 덜게되었습니다.</p>
<p>저희는 또한 레슨 5에서 심볼은 변수와 함수, 그리고 documentation, print name, properties를 위한 값을 가질 수 있다고 배웠습니다. 심볼의 property list는 다수의 키/값 쌍이 symbol과 연결된 아주 작은 데이터베이스와 같습니다. 예를들어, 여러분의 프로그램이 object를 표현하고 다룬다면, object에 관한 정보를 property list에 저장할 수 있습니다:</p>
<pre><code class="language-lisp">(setf (get 'object-1 'color) 'red)
;;=&gt; RED

(setf (get 'object-1 'size) 'large)
;;=&gt; LARGE

(setf (get 'object-1 'shape) 'round)
;;=&gt; ROUND

(setf (get 'object-1 'position) '(on table))
;;=&gt; (ON TABLE)

(setf (get 'object-1 'weight) 15)
;;=&gt; 15

(symbol-plist 'object-1)
;;=&gt; (WEIGHT 15 POSITION (ON TABLE) SHAPE ROUND SIZE LARGE COLOR RED)

(get 'object-1 'color)
;;=&gt; RED

object-1
;;&gt;| Error: no value
</code></pre>
<p>OBJECT-1은 값을 갖지 않는다는 점을 주목하시기 바랍니다 - 모든 유용한 정보는 두 곳에 있습니다: 심볼의 identify와 심볼의 properties.</p>
<p>이러한 property의 이용은 현대 object programming보다 몇 십년이나 앞서 나왔습니다. 이는 object의 필수적인 3가지 매커니즘중 2가지를 제공합니다: 식별자identify와 캡슐화encapsulation (property 값 역시 함수가 될 수 있다는 것을 명심하시기 바랍니다). 3번째 매커니즘, 상속inheritance은 다른 &quot;object&quot;를 link하여 simulate합니다.</p>
<p>Property는 현대 리스프 프로그램에서 거의 사용되지 않습니다. 해쉬테이블Hashtables (아래 참조) [p 73] , (다음 section에서 기술된) 구조체structures , CLOS objects(7장 [p 117]과 14장 [p 157] 참조)는 사용하기에 더 편리하며 더욱 효율적인 방식으로 property lists의 모든 기능을 제공합니다. 현대 리스프 개발 시스템은 property에 파일과 심볼을 정의하는 form의 파일 위치, 함수의 인자 리스트의 정의와 같은 (프로그래밍 환경에서 유용한 도구로 이용하기 위한) 특정 정보를 기록하여 프로그램에 주석을 다는 목적으로 주로 사용합니다.</p>
<h2 id="structures-let-you-store-related-data"><a class="header" href="#structures-let-you-store-related-data">Structures let you store related data</a></h2>
<p>리스프 구조체는, 명명된 slot과 관계된 데이터를 저장하는, object를 생성하는 방법을 여러분에게 제시합니다.</p>
<pre><code class="language-lisp">(defstruct struct-1 color size shape position weight)
;;=&gt; STRUCT-1

(setq object-2 (make-struct-1
                              :size 'small
                              :color 'green
                              :weight 10
                              :shape 'square))
;;=&gt; #S(STRUCT-1 :COLOR    GREEN
                 :SIZE     SMALL 
                 :SHAPE    SQUARE
                 :POSITION NIL
                 :WEIGHT   10)

(struct-1-shape object-2)
;;=&gt; SQUARE

(struct-1-position object-2)
;;=&gt; NIL

(setf (struct-1-position object-2) '(under table))
;;=&gt; (UNDER TABLE)

(struct-1-position object-2)
;;=&gt; (UNDER-TABLE)
</code></pre>
<p>이 예에서, 저희는 COLOR, SHAPE, SIZE, WEIGHT의 slot을 지닌 STRUCT-1 구조체를 정의하였습니다. 그런 다음 STRUCT-1의 instance를 만들고, 그 instance에 변수 OBJECT-2를 할당하였습니다. 예제의 나머지 부분은, struct-slot 이름으로된 접근자assessor 함수를 이용하여, 어떻게 구조체 instance의 slot에 접근하는지를 보여줍니다. 리스프는 DEFSTRUCT를 이용하여 구조체를 정의할때 make-structname과 structname-slotname 함수를 생성합니다.</p>
<p>6장[p 112]에서 DEFSTRUCT의 optional 기능에 대해 살펴볼 것입니다.</p>
<h2 id="type-information-is-apparent-at-runtime"><a class="header" href="#type-information-is-apparent-at-runtime">Type information is apparent at runtime</a></h2>
<p>심볼은 runtime시 어떠한 변수 타입과도 연관지을 수 있습니다. 이것이 문제되는 경우에 대해, 리스프는 저희에게 값의 타입을 묻는것을 허용합니다</p>
<pre><code class="language-lisp">(type-of 123)
;;=&gt; FIXNUM

(type-of 123456789000)
;;=&gt; BIGNUM

(type-of &quot;hello, world&quot;)
;;=&gt; (SIMPLE-BASE-STRING 12)

(type-of 'fubar)
;;=&gt; SYMBOL

(type-of '(a b c))
;;=&gt; CONS
</code></pre>
<p>TYPE-OF 는 인자의 종류type를 나타내는 심볼이나 리스트를 반환합니다. 게다가 이 정보는 인자의 종류의 기반하는 프로그램의 행동을 설명하는데 이용할 수 있습니다. TYPECASE 함수는 type 질의inquiry와 COND-와같은 분기dispatch를 결합한 것입니다.</p>
<p>CLOS(14장 [p 157] 참조)S의 제네릭 함수의 도입으로, TYPE-OF는 예전만큼 중요하지는 않습니다.</p>
<h2 id="hash-tables-provide-quick-data-access-from-a-lookup-key"><a class="header" href="#hash-tables-provide-quick-data-access-from-a-lookup-key">Hash Tables provide quick data access from a lookup key</a></h2>
<p>해쉬 테이블은 값과 고유키unique key와 관련있습니다. property list완 다르게, 해쉬 테이블은 엄청나게 많은 키/값쌍에 매우 적합하지만, 작은 연관 set에 대해 엄청난 overhead를 감수해야합니다.</p>
<pre><code class="language-lisp">(setq ht1 (make-hash-table))
;;=&gt; #&lt;HASH-TABLE&gt;

(gethash 'quux ht1)
;;=&gt; NIL
;;=&gt; NIL

(setf (gethash 'baz ht1) 'baz-value)
;;=&gt; BAZ-VALUE

(gethash 'baz ht1)
;;=&gt; BAZ-VALUE
;;=&gt; T

(setf (gethash 'gronk ht1) nil)
;;=&gt; NIL

(gethash 'gronk ht1)
;;=&gt; NIL
;;=&gt; T
</code></pre>
<p>MAKE-HASH-TABLE을 이용하여 해쉬 테이블을 생성하며, GETHASH를 이용하여 값에 접근합니다. GETHASH는 두 값을 반환합니다. 첫번째는 키와 관련있는 값입니다. 두번째는 키를 찾으면 T, 아니면 NIL입니다. 위 예제에서 처음과 마지막 GETHASH form의 차이를 주목하시기 바랍니다.</p>
<p>기본적으로, 해쉬테이블은 EQ(이는 숫자나 list가 아닌 심볼에 대해서만 동작합니다)를 이용하여 이의 키를 비교하기 위해 만들어졌습니다. 17장[p 174]에서 동일성equality 판단predicates에 대해 더 자세히 배울 것입니다. 지금은, 다수의 키를 이용하고자 한다면, 이 폼을 이용하여 해쉬테이블을 만들어야한다는 것을 명심하시기 바랍니다:
(make-hash-table :test #'eql)</p>
<p>리스트를 키로 사용하고자 한다면, 이렇게 해쉬테이블을 만듭니다:
(make-hash-table :test #'equal)</p>
<p>키를 없애고자한다면, form (REMHASH key hash-table)를 이용합니다. 그리고 키에 해당하는 값을 바꾸고자한다면, 키/값쌍을 추가했던것처럼 GETHASH와 SETF를 이용합니다.</p>
<h2 id="packages-keep-names-from-colliding"><a class="header" href="#packages-keep-names-from-colliding">Packages keep names from colliding</a></h2>
<p>프로그램을 작성하는것에 관한 어려운 일중 하나는 프로그램의 이름을 짓는 부분입니다. 한편으론, 기억하기 쉽고 명명된 object의 규칙과 목적을 환기evocative시켜주는 이름을 이용하기 원할 것입니다. 다른 한편으론, 언젠가 여러분의 프로그램과 작업하게될, 다른 프로그램의 어딘가에 이미 사용한 (혹은 사용될 것 같은)이름을 이용하지 않길 원할 것입니다.</p>
<p>이름충돌naming conflict을 피하는 법 중 하나는 프로그램에 있는 모든 이름에 누구도 사용하지 않는 고유 접두사prefix를 붙이는 것입니다. 여러분은 이것이 라이브러리에 매번 필요하다고 생각할 것입니다 - 보통 하나에서 세개정도 문자의 접두사가 있다. 불행히도, 여전히 두 소프트웨어 개발자가 동일한 prefix를 선택하기 위한 많은 관문이 남아있습니다; 유달히 몇몇 prefix들이 다른 것보다 더욱 evocative하기 때문입니다. 여러분이 생산한 모든 소프트웨어를 제어하고자 한다면, 모든 prefix를 선택하고 문제를 피할 수 있습니다. prefix naming scheme을 이용하는 third-parfy 소프트웨어를 사고자 한다면, 제조사에 의해 선택된 이름에 관련된 일을 해야할 것이며, 두 제조사가 우연히 동일한 prefix를 사용하지 않기를 희망할 것입니다.</p>
<p><img src="../res/prefixed-names..gif" alt="prefixed-names.gif" /></p>
<p>naming conflicts 피하는 또 하나의 방법은 qualified name을 이용하는 것입니다. 이를 하기 위해선, 언어가 프로그래머에 의해 정의되고 제어되는 분리된 이름공간의 지원을 제공해야 합니다. 어떻게 이것이 동작하는지 이해하기 위해, 프로그램을 위해 여러분이 만든 모든 이름이 여러분의 이름이 타이틀 상단에 쓰여진 한장에 종이에 작성되었다고 상상해보시기 바랍니다. 이름이 이용하기에 안전한지 확인하기 위해선, 여러분이 이 페이지에 작성한 이름 목록을 확인하기만 하면 됩니다. 누군가의 소프트웨어가 여러분의 프로그램의 서비스를 필요로 할때, 그것은 여러분의 qualifier와 name을 이용하여 여러분의 이름을 참조합니다. 다른이의 소프트웨어는 다른 qualifier를 지니고 그들의 qualifier는 그들만의 name을 암시하기에(이것을 작성할 필요는 없습니다), 이름 충돌을 피할 방도가 없습니다.</p>
<p>여러분은 qualifier는 이름에 prefix를 붙이기 위한 복잡한 방법에 지나지 않는다고 생각할 것입니다. 그러나, 거기엔 미묘하며 중대한 차이점이 있습니다. prefix는 이름의 일부입니다; 이는 한번 작성되면 바뀔 수 없습니다. qualifier는 이가 qualify한 이름에서 분리되었으며, 정확히 한 장소에서 &quot;작성&quot;되었습니다. 더욱이, 여러분은 이름들이 쓰여진 &quot;종이&quot;를 가리켜 이를 &quot;그러한 이름들&quot;이라 말할 수 있습니다. 다른 프로그래머와 동일한 qualifier를 선택하게 된다면, 여러분은 여전히 여러분이 선택한 qualifier에 의해 &quot;그 이름&quot;을 참조할 수 있습니다 - 다른 말로 하자면, 여러분이 사용할 소프트웨어가 출고된 후에도, 여러분은 qualifier를 바꿀 수 있습니다.</p>
<p><img src="../res/rename-package.gif" alt="rename-package.gif" /></p>
<p>위 예제에는, 파일 LIB1과 LIB2에서 가져온 두 라이브러리가 있습니다. 두 라이브러리 설계자는, 리스프에서 package 이름으로 알려진, 이름 공간namespace을 위해 UTIL이란 이름을 사용하였습니다. 각 라이브러리는 client에게 보여지는 이름들을 나열list했습니다. 두 라이브러리를 이용하는 프로그래머는 MY-PACKAGE란 package 이름에서 코드를 작성합니다. 각 라이브러리를 로드한후, 프로그래머는 이의 package의 이름을 다른 이름으로 바꿉니다. 그러면, UTIL-1:INITIALIZE와 UTIL-2:INITIALIZE의 호출에서 봤던 것처럼, 라이브러리에 있는 이름들은 이름이 바뀐 qualifier를 이용하여 참조됩니다. 프로그래머는 여전히 qualify 폼이 아닌 INITIALIZE 이름은 이용할 수 있다는 것을 주목하시기 바랍니다 - 이는 MY-PACKAGE:INITIALIZE와 동일합니다.</p>
<p>리스프는 package facility라 알려진 함수와 매크로를 통해 이러한 기능을 제공합니다. DEFPACKAGE 매크로는 간편하게 대부분의 package 연산을 제공하는데 반해, IN-PACKAGE 매크로는 현재 package를 설정합니다:</p>
<pre><code class="language-lisp">;;;; file: util1.lisp
(defpackage util1
  (:export init func1 func2)
  (:use common-lisp))
(in-package util1)

(defun init () 'util1-init)
(defun func1 () 'util1-func1)
(defun func2 () 'util1-func2)
</code></pre>
<pre><code class="language-lisp">;;;; file: util2.lisp
(defpackage util2
  (:export init func1 func2)
  (:use common-lisp))
(in-package util2)

(defun init () 'util2-init)
(defun func1 () 'util2-func1)
(defun func2 () 'util2-func2)
</code></pre>
<pre><code class="language-lisp">;;;; file: client.lisp
(defpackage client
  (:use common-lisp)
  (:import-from util1 func1)
  (:import-from util2 func2))
(in-package client)

(defun init () 'client-init)

(util1:init)
(util2:init)
(init)
(func1)
(func2)
</code></pre>
<p>예제는 세개의 파일의 내용물을 나열했습니다. File 1과 File 2는 모두 동일한 이름으로 3개의 함수를 정의하였습니다. File 1은 이름을 UTIL1 package에 넣었으며, File 2는 UTIL2 package를 이용합니다. <code>defpackage</code> 폼은 package의 이름을 지어줍니다. <code>:use</code> 옵션은 다른 pakcage에서 qualification없이 사용될 이름을 지정하는 반면, :EXPORT 옵션은 package에서 client에게 노출될 이름을 지정합니다.</p>
<p><code>defpackage</code> 폼은 단지 pakcage를 생성합니다. <code>use-package</code> 폼은 package를 current로 만듭니다 -  qualify가 되지 않은 모든 이름들은 current입니다. COMMON-LISP:<em>PACKAGE</em> 변수는 항상 current package를 포함합니다.</p>
<p>File 3은 CLIENT package를 만듭니다. :INFORT-FROM 옵션은 UTIL1과 UTIL2 package로부터 특정 이름을 가져옵니다 - 이러한 이름들은 CLIENT package에서 qualification 없이 사용되어집니다. UTIL1나 UTIL2에서 export되었지만 CLIENT에서 import된 이름들은, form pakcage:name 의 명시적explicit qualifier를 이용하여 CLIENT에 의해 참조될 수 있습니다.</p>
<p>이번 section에선 아주 기초적인 package 연산만을 다루었습니다. 31장[p 247]에서, 큰 규모의 소프트웨어 시스템을 구성에서의 package를 살펴볼때, 좀더 세부적인걸 다룰 것입니다.</p>
<h2 id="짚고-넘어가기"><a class="header" href="#짚고-넘어가기">짚고 넘어가기</a></h2>
<ul>
<li><code>read</code></li>
<li><code>write</code></li>
<li><code>read-char</code></li>
<li><code>write-char</code></li>
<li><code>make-array</code></li>
<li><code>aref</code></li>
<li><code>vector</code></li>
<li><code>elt</code></li>
<li><code>string</code></li>
<li><code>type-of</code></li>
<li><code>make-hash-table</code></li>
<li><code>gethash</code></li>
<li><code>remhash</code></li>
<li><code>defstruct</code></li>
<li><code>defpackage</code></li>
<li><code>in-package</code></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../ch03/lesson_09.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../ch03/lesson_11.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../ch03/lesson_09.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../ch03/lesson_11.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
