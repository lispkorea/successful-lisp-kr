<!DOCTYPE HTML>
<html lang="kr" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Successful Lisp - 한국어판</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="Successful Lisp">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Index.html">들어가며</a></li><li class="chapter-item expanded affix "><li class="part-title">03. 12개의 레슨으로 배우는 필수 리스프</li><li class="chapter-item expanded "><a href="ch03/ch03.html">03. 12개의 레슨으로 배우는 필수 리스프</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03/lesson_01.html">레슨 01. 필수 - 신택스</a></li><li class="chapter-item expanded "><a href="ch03/lesson_02.html">레슨 02. 필수 - 평가</a></li><li class="chapter-item expanded "><a href="ch03/lesson_03.html">레슨 03. 스페셜 폼과 매크로에 대한 예제</a></li><li class="chapter-item expanded "><a href="ch03/lesson_04.html">레슨 04. 조립과 분해</a></li><li class="chapter-item expanded "><a href="ch03/lesson_05.html">레슨 05. 네이밍과 아이덴티티</a></li><li class="chapter-item expanded "><a href="ch03/lesson_06.html">레슨 06. 바인딩 vs 할당</a></li><li class="chapter-item expanded "><a href="ch03/lesson_07.html">레슨 07. 필수 - 함수 정의</a></li><li class="chapter-item expanded "><a href="ch03/lesson_08.html">레슨 08. 필수 - 매크로 정의</a></li><li class="chapter-item expanded "><a href="ch03/lesson_09.html">레슨 09. 필수 - 다중 값</a></li><li class="chapter-item expanded "><a href="ch03/lesson_10.html">레슨 10. 프리뷰 - 다른 데이터 타입</a></li><li class="chapter-item expanded "><a href="ch03/lesson_11.html">레슨 11. 필수 - 입력과 출력</a></li><li class="chapter-item expanded "><a href="ch03/lesson_12.html">레슨 12. 필수 - 리더 매크로</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Successful Lisp - 한국어판</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/lispkorea/successful-lisp-kr" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="들어가며"><a class="header" href="#들어가며">들어가며</a></h1>
<ul>
<li>
<p><code>David Lamkins의 Successful Lisp</code> 한국어 번역본입니다.</p>
<ul>
<li>번역을 허락해주셔서 감사합니다 <code>David Lamkins</code>.</li>
<li>그의 웹사이트는 <a href="http://lamkins.net">http://lamkins.net</a>, github는 <a href="https://github.com/TieDyedDevil">https://github.com/TieDyedDevil</a>입니다.</li>
<li>그의 책은 아마존 닷컴 <a href="https://www.amazon.com/exec/obidos/ASIN/3937526005/daviblamkwebs-20?creative=327641&amp;camp=14573&amp;link_code=as1">이곳</a>에서 원서로 구입할 수 있으며 온라인 버전은 <a href="https://dept-info.labri.fr/~strandh/Teaching/MTP/Common/David-Lamkins/contents.html">이곳</a>에서 볼 수 있습니다.</li>
<li><code>Successful Lisp의 모든 저작권은 David Lamkins에게 있습니다.</code></li>
</ul>
</li>
<li>
<p>This is Korean translation version of <code>David Lamkins's Successful Lisp</code>.</p>
<ul>
<li><code>David Lamkins</code>, Thank you for allowing me to translate your book.</li>
<li>His personnal website is <a href="http://lamkins.net">http://lamkins.net</a>, github is <a href="https://github.com/TieDyedDevil">https://github.com/TieDyedDevil</a>.</li>
<li>You can buy His original book on Amazon.com <a href="https://www.amazon.com/exec/obidos/ASIN/3937526005/daviblamkwebs-20?creative=327641&amp;camp=14573&amp;link_code=as1">here</a> and you can check his online version of successfull lisp <a href="https://dept-info.labri.fr/~strandh/Teaching/MTP/Common/David-Lamkins/contents.html">here</a>.</li>
<li><code>David Lamkins owns All of Successful Lisp's copyright.</code></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="03-12개의-레슨으로-배우는-필수-리스프"><a class="header" href="#03-12개의-레슨으로-배우는-필수-리스프">03. 12개의 레슨으로 배우는 필수 리스프</a></h1>
<p>이번 장은 여러분에게 리스프를 시작하기에 앞서 알아야 할 모든것을 가르칠 것입니다.</p>
<p>언어의 코어 기능들을 모두 다룰 것입니다. 여러분이 이 코어를 리스프 자체라 생각하고, 그렇지 않은 것은 하나의 거대한 표준 라이브러리라 생각하셨으면 합니다. 책을 읽은 후 이를 배경으로, <code>Common Lisp : The Language, 2nd Edition</code>과 같은 메뉴얼을 참조하면, 더욱 편하게 리스프의 남은 부분들을 배울 수 있을 것입니다.</p>
<p>여러분은 이번 장을 한번에 쭉 읽어야 합니다. 이따금 다음 단락이나 다음 장에대해 언급하겠지만, 이번장을 이해하기 위해서 반드시 그러한 참고들을 따를 필요는 없습니다. 이번 장을 끝낼 무렵, 여러분은 이미 리스프 시스템의 키보드 앞에 앉아 4장을 진행하고 있을 것 입니다.</p>
<h2 id="짚고-넘어가기"><a class="header" href="#짚고-넘어가기">짚고 넘어가기</a></h2>
<ul>
<li><a href="https://www.cs.cmu.edu/Groups/AI/html/cltl/cltl2.html">Common Lisp : The Language, 2nd Edition</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="레슨-01-필수---신택스essential-syntax"><a class="header" href="#레슨-01-필수---신택스essential-syntax">레슨 01. 필수 - 신택스(Essential Syntax)</a></h1>
<ul>
<li><a href="https://dept-info.labri.fr/~strandh/Teaching/MTP/Common/David-Lamkins/chapter03-01.html">원문</a></li>
</ul>
<h2 id="리스트는-괄호로-감싸져있다"><a class="header" href="#리스트는-괄호로-감싸져있다">리스트는 괄호로 감싸져있다.</a></h2>
<p>리스프에 대해 우선적으로 알아할 것입니다: 괄호로 둘러싸인 모든것은 <code>리스트(list)</code>이다.</p>
<p>여기 예가 있습니다:</p>
<pre><code class="language-lisp">(1 2 3 4 5)

(a b c)

(cat 77 dog 89)
</code></pre>
<p>앞서 말씀드린대로, 괄호로 둘러싸인 것은 <code>리스트</code>입니다.</p>
<p>이와 같은 말을 들으면, 아마 다음과 같은 의문이 생길 것입니다:</p>
<ol>
<li>괄호로 아무것도 없는것을 둘러싼다면?</li>
<li>괄호로 다른 리스트를 둘러싼다면?</li>
</ol>
<p>두 경우 모두 대답은 같습니다. 여전히 <code>리스트</code>입니다.</p>
<p>따라서 다음 나오는 것들 또한 <code>리스트</code>입니다:</p>
<pre><code class="language-lisp">()

(())

((()))

((a b c))

((1 2) 3 4)

(mouse (monitor 512 342) (keyboard US))

(defun factorial (x) (if (eql x 0) 1 (* x (factorial (- x 1)))))
</code></pre>
<p>리스트가 아닌 유일한 경우는 다음 4개의 예제에 나온 것처럼, 좌/우측 괄호가 짝을 이루지 못하는 경우입니다:</p>
<pre><code class="language-lisp">(a b c(                   ; (: 2개 // ): 0개

((25 g) 34                ; (: 2개 // ): 1개

((())                     ; (: 3개 // ): 2개

(()))                     ; (: 2개 // ): 3개
</code></pre>
<p>크게 신경쓸 부분은 아닙니다: 리스프는 괄호가 일치하지 않으면 않다고 여러분에게 알려 줄 것입니다.
또, 리스프 프로그램을 작성하기 위해 사용하는 편집기 대부분은 자동적으로 일치하는 괄호를 찾는 방법을 제공해 줄 것입니다. 27장에서 편집기에 대해 살펴볼 수 있습니다 [p 227].</p>
<p>리스프에서 <code>리스트</code>는 여러가지가 될 수 있습니다. 가장 일반적인 경우, <code>리스트</code>는 프로그램이나 데이터가 될 수 있습니다. 그리고 <code>리스트</code>가 스스로 다른 리스트를 만들 수 있기에, 여러분은 복잡한 데이터의 조합과 여러 단계의 리스트 구조로 된 프로그램을 가질 수 있습니다. 이를 잘 이해하는 자에게는 리스프는 엄청난 유연성을 부여해 줄 것이며, 그렇지 않은 자에게는 많은 혼란을 줄 것입니다. 이번장을 계속해서 나아가면서 이러한 혼란을 없애도록 노력해 봅시다.</p>
<h2 id="아톰atom은-공백이나-괄호로-분리된-것입니다"><a class="header" href="#아톰atom은-공백이나-괄호로-분리된-것입니다">아톰(Atom)은 공백이나 괄호로 분리된 것입니다.</a></h2>
<p>이제 여러분은 리스트를 구분할 수 있으며, 괄호 사이에 나타나지만 (리스트가 아닌)단어나 숫자인 것들에 대한 것들을 뭐라고 부르는지 알고 싶을 것입니다. 이러한 것들을 <code>아톰(atom)</code>이라 부릅니다.</p>
<p>그러므로, 다음 단어와 숫자들은 모두 <code>아톰</code>입니다:</p>
<pre><code class="language-lisp">1

25

342

mouse

factorial

x
</code></pre>
<p>리스프에서는 거의 모든 문자를 이용하여 아톰을 구성할 수 있습니다. 이제부터 문자, 숫자, 구두점 문자들이 있는데 이들 앞뒤에 공백(줄의 시작 또는 끝 포함) 또는 괄호가 있으면 이를 모두 <code>아톰</code>이라고 부르겠습니다. 다음 나오는 것들은 모두 <code>아톰</code>입니다:</p>
<pre><code class="language-lisp">-

*

@comport

funny%stuff

9^

case-2
</code></pre>
<p>만일 다른 프로그래밍에 대한 경험이 있다면, 한가지 주의해야 할 점은 보통 다른 언어에서 연산자로 예약된 문자들이 리스프에서 아톰으로써 쓰였다면 별다른 의미를 갖지 않는다는 것입니다. 예를들어, <code>case-2</code>는 수학적(arithmetic) 표현식 뺄샘이 들어간게 아니라 여기서는 그져 <code>아톰</code> 그 자체입니다.</p>
<p>공백이나 괄호로 무엇이 <code>아톰</code>인지 구분할 수 있으므로, 아톰과 괄호 혹은 괄호들 사이에 있는 공백을 없앨 수 있습니다. 그러므로, 다음 두 예제는 동일합니다:</p>
<pre><code class="language-lisp">(defun factorial (x) (if (eql x 0) 1 (* x (factorial (- x 1)))))

(defun factorial(x)(if(eql x 0)1(* x(factorial(- x 1)))))
</code></pre>
<p>사실, 여러분은 절대로 두번째에 나타난것처럼 리스트를 작성해서는 안됩니다. 여러분은 가독성을 향상시키기 위해 리스트를 여러 라인으로 분리시키며 각 라인을 적절히 들여써야 합니다. 이 리스트는 사실 작은 프로그램이며, 다음과 같이 들여쓰면 리스퍼 프로그래머가 읽기 수월해 집니다:</p>
<pre><code class="language-lisp">(defun factorial (x)
  (if (eql x 0)
      1
      (* x (factorial (- x 1)))))
</code></pre>
<p>지금, 여러분은 이것이 무얼 의미하는지, 이러한 종류의 들여쓰기(indentation)가 무엇인지 대해 걱정할 필요가 없습니다. 이번장을 통해, 여러분은 들여쓰기가 들어간 많은 예제를 접하게 될 것입니다.</p>
<p>계속해서 보여드리는 예제와 함께, 가독성을 향상시키는 들여쓰는 방법에 대해 알려드릴 것입니다. 28장 [p 230]에서 적절한 들여쓰는 법을 포함하여, 리스프의 코딩 스타일에 대해 다룰 것입니다.</p>
<h2 id="짚고-넘어가기-1"><a class="header" href="#짚고-넘어가기-1">짚고 넘어가기</a></h2>
<ul>
<li>리스트(list)</li>
<li>아톰(atom)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="레슨-02-필수---평가essential-evaluation"><a class="header" href="#레슨-02-필수---평가essential-evaluation">레슨 02. 필수 - 평가(Essential Evaluation)</a></h1>
<ul>
<li><a href="https://dept-info.labri.fr/~strandh/Teaching/MTP/Common/David-Lamkins/chapter03-02.html">원문</a></li>
</ul>
<h2 id="폼form은-평가될-수-있습니다"><a class="header" href="#폼form은-평가될-수-있습니다">폼(form)은 평가될 수 있습니다.</a></h2>
<p><code>폼(form)</code>은 <code>아톰(atom)</code> 혹은 <code>리스트(list)</code>가 될 수 있습니다. 중요한 것은 <code>폼</code>이 <code>평가(evaluation)</code>된다는 것입니다. 평가라는 것은 상당한 기술적 의미를 지니고 있으며, 이번 섹션에서 서서히 그 모습을 드러나게 될 것입니다.</p>
<p><code>폼</code>이 아톰이라면 평가는 단순합니다. 리스프는 아톰을 마치 이름처럼 다루고, 값이 존재한다면 이름에 저장된 값을 얻습니다. 여러분은 아마도 왜 제가 아톰은 변수라고 직접적으로 말하지 않는지 의아할 것입니다. 명확하게 정의하지 않은 이유는 아톰은 변수이거나 상수의 값을 가질 수 있기 때문입니다. 그리고 아톰의 값은 경우에 따라 상수가 될 수 도 있습니다.</p>
<p>숫자는 <code>아톰</code>입니다(이 값은 상수입니다). 리스프는 숫자에 값을 저장 할 수 없습니다: 숫자는 자체적으로 평가됩니다.</p>
<p>정의가 완전히 내려지지 않은 새로운 용어를 소개합니다. 이제, 심볼을 값을 가질 수 있는 <code>아톰</code>이라고 여기기 바랍니다. 레슨 5[p 53]에서 심볼에 대해 더욱 자세히 살펴볼 것입니다.</p>
<p><code>defconstant</code>로 정의된 심볼은 상수 값을 지닙니다. 리스프는 변수처럼 아톰에 값을 저장한 다음, 값을 바꿀 수 없다라는 메모를 추가합니다.</p>
<p>패키지에 있는 <code>키워드(keyword) 심볼</code>은 스스로 평가됩니다. 패키지에 관한 것은 31장[p 247]에서 자세히 살펴볼 것입니다. 지금, 여러분이 알아야 할것은 (패키지 프리픽스라 불리는) <code>:</code> 문자로 시작하는 심볼은 <code>키워드 심볼</code>이라는 것입니다. <code>키워드 심볼</code>은 그 자신을 값으로 갖습니다.</p>
<p>다양한 방식으로 심볼에서 값을 얻을 수 있습니다. 리스프는 실제로 심볼에 다양한 값을 저장합니다. 하나는 변수로서의 심볼의 값. 그리고 다른 하나는 함수로서 심볼입니다. 또 다른 것들은 해당 심볼에 대한 문서를 얻거나, 출력값으로 활용하거나, 연관리스트(associated list)처럼 속성값으로 쓰이기도 합니다. 이러한 것들에 대해 레슨 5 [p 53], 레슨 6 [p 56], 레슨 7 [p 59]에서 더욱 자세히 살펴볼 것입니다.</p>
<p>폼이 리스트라면, 첫번째 요소는 심볼이거나 람다(lambda)표현식이라 불리는 특별한 폼일 것입니다. (람다 표현식에 대한것은 잠시 뒤로 미루겠습니다.)
심볼은 함수의 이름을 짓습니다. 리스프에서 심볼 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>는 일반적인 산술 연산자입니다: 덧셈, 빨셈, 곱셈, 나누기. 각 심볼은 산술 연산을 수행하는 함수와 연관되어있습니다.</p>
<p>따라서 리스프가 폼 <code>(+ 2 3)</code>을 평가하면, 이는 덧셈 함수<code>+</code>에 인자 <code>2</code>와 <code>3</code>을 적용시킬 것이며, 예상되듯이 결과 <code>5</code>를 반환할 것입니다. 함수로서 심볼 <code>+</code>가 인자들 앞에 있습니다. 이는 <code>전위 표기법(prefix notation)</code>입니다. 리스프가 리스트를 폼으로 평가하기 위해 무얼할 것인지 이해하기 위해선, 리스트의 첫번째 요소를 살펴보시기 바랍니다.</p>
<h2 id="함수는-인자를-받을-수-있습니다"><a class="header" href="#함수는-인자를-받을-수-있습니다">함수는 인자를 받을 수 있습니다.</a></h2>
<p>주어진 리스트를 평가할때 리스프는 폼을 함수 호출로써 다룹니다. 지금부터 우리는 수 많은 리스프의 평가를 보게 될 것이며, 리스프의 입력과 이의 반응을 구분하기 위해 다음과 같이 시각적 표시를 할 것입니다:</p>
<pre><code class="language-lisp">(어떠한 리스프 입력)
;;=&gt; 리스프 평가의 결과

;;&gt;&gt; 리스프 출력
;;&lt;&lt; 리스프에 입력
;;&gt;| 리스프의 에러 메시지
</code></pre>
<p>예:</p>
<pre><code class="language-lisp">(+ 4 9)
;;=&gt; 13

(- 5 7)
;;=&gt; -2

(* 3 9)
;;=&gt; 27

(/ 15.0 2)
;;=&gt; 7.5
</code></pre>
<p>위 경우에서 보듯이, 평가된 폼은 리스트입니다. 각각의 첫번째 요소는 심볼이자 함수의 이름입니다. 남아있는 요소는 해당 함수의 인자입니다. 여기서, 인자는 모두 숫자이며, 숫자는 스스로 평가된다는 것을 알 수 있습니다.</p>
<p>여기 몇몇 예제가 더 있습니다:</p>
<pre><code class="language-lisp">(atom 123)
;;=&gt; T

(numberp 123)
;;=&gt; T

(atom :foo)
;;=&gt; T

(numberp :foo)
;;=&gt; NIL
</code></pre>
<p><code>atom</code>과 <code>numberp</code>는 술어(predicate)입니다. 술어는 참 혹은 거짓을 반환합니다. 리스프에서 <code>NIL</code>은 거짓을 나타냅니다. <code>NIL</code>이 아닌 것은 모두 참입니다. 딱히 의미있는 값이 아니면 술어는 관습적으로 참을 의미하는 <code>T</code>를 반환하게 되어 있습니다. <code>atom</code>은 인자가 리스프의 아톰이라면 <code>T</code>를 반환합니다. <code>numberp</code>는 인자가 숫자이면 <code>T</code>를 반환합니다.</p>
<p>위의 폼들을 평가하기 위해, 리스프는 우선 (좌측에서 우측으로) 인자를 평가하고, 그런 다음 첫번째 요소를 평가하여 함수를 얻은 후, 앞선 인자들을 함수에 적용합니다. 몇몇 예외가 있지만, 그것들은 이번 레슨의 끝부분에서 배울 것입니다.</p>
<p>리스프는 리스트 폼을 평가하기 위해 다음과 같은 작업을 수행합니다:</p>
<ol>
<li>나머지 요소들을 좌측에서부터 우측으로 인자들을 평가한다.</li>
<li>첫번째 요소에서 함수를 얻는다.</li>
<li>함수에 인자들을 적용한다.</li>
</ol>
<p><code>아톰</code> 또한 <code>리스프의 폼</code>이라는 것을 명심하시기 바랍니다. 주어진 아톰이 평가되면, 리스프는 아톰이 지닌 값을 반환합니다:</p>
<pre><code class="language-lisp">17.95
;;=&gt; 17.95

:A-KEYWORD
;;=&gt; :A-KEYWORD

*FEATURES*
;;=&gt; (:ANSI-CL :CLOS :COMMON-LISP)

&quot;Hello, world!&quot;
;;=&gt; &quot;Hello, world!&quot;

WHAT-IS-THIS?
;;&gt;| Error: Unbound variable
</code></pre>
<p>숫자와 키워드는 스스로 평가됩니다. 문자열도 그러합니다. <code>*FEATURES*</code>는 리스프에 의해 미리 정의된 변수입니다. 여러분의 시스템은 아마도 다른 값을 반환할 것입니다.</p>
<p>심볼 <code>WHAT-IS-THIS?</code>는 리스프에 의해 미리 정의되지 않아 값을 지니지 않으며, 이에 값을 얻을 수 없습니다. 시스템은 값 대신에 에러메시지로 응답할 것입니다. 에러 메시지 앞에 <code>;;&gt;|</code>를 붙여 표시하였습니다. 시스템에 따라 다른 에러 메시지가 출력될 수 있습니다.</p>
<h2 id="함수는-다수의-값을-반환-할-수-있다"><a class="header" href="#함수는-다수의-값을-반환-할-수-있다">함수는 다수의 값을 반환 할 수 있다.</a></h2>
<p>우리는 종종 다수의 값을 반환하는 함수를 갖길 원합니다. 예를들어, 데이터베이스 전체를 살펴보는 함수는 요구하는 값과 완료상태코드를 동시에 반환해야 합니다. 이를 행할 방법으로는 해당 결과값을 저장할 위치 자체를 함수에 전달하는 것입니다; 가능은 하지만, 리스프 프로그램에서는 매우 드믄 일입니다.</p>
<p>또 다른 접근법은 결과와 상태코드를 하나로 묶어 하나의 반환 값으로 만드는 것입니다.
리스프는 구조체[p 72]를 포함하여 여러분에게 이를 수행할 다양한 방식을 제공합니다. 다만, 이와같이 하나로 묶는 방식은 잘못하면 가비지(29장 [p 238] 참조)가 생성되어 프로그램 작동 속도가 느려지게 만들 수 있기에 숙련된 리스프 프로그래머는 이와 같은 작업을 피합니다.</p>
<p>함수에서 다수의 값을 반환하는 올바른 법은 <code>values</code> 폼을 이용하는 것입니다. 잠시 후에 함수 컨텍스트안에서의 VALUES의 사용법을 [p 63]에서 살펴보도록 하겠습니다. 지금은, 리스프가 <code>values</code> 폼을 평가할때 무슨 일이 벌어지는지 살펴봅시다:</p>
<pre><code class="language-lisp">(values 1 2 3 :hi &quot;Hello&quot;)
;;=&gt; 1
;;=&gt; 2
;;=&gt; 3
;;=&gt; :HI
;;=&gt; &quot;Hello&quot;
</code></pre>
<p>리스프가 <code>values</code> 폼으로 각 인자에 대한 값을 반환하는 것을 확인할 수 있습니다.</p>
<h2 id="함수에서-인자를-수정하지-않는다"><a class="header" href="#함수에서-인자를-수정하지-않는다">함수에서 인자를 수정하지 않는다.</a></h2>
<p>앞서, 결과값을 저장할 위치 자체를 인자로 함수에 넘길 수 있으며, 함수가 그 위치의 값을 바꿀 수도 있다고 말한 바가 있습니다. 다른 언어들은 이를 일반적인 레파토리로 말할지라도, 리스프 프로그램에서 매우 드문 일입니다.</p>
<p>저장할 위치에 키워드가 아닌 심볼이나 구조체 같은 것을 넣을 수 는 있습니다. 심볼을 넣을 경우, 함수는 심볼에 새로운 값을 넣는 코드를 수행해야만 합니다. 구조체를 넣을 경우 구조체의 각 값을 올바르게 변경하는 코드를 수행해야만 합니다. 이러한 작업 자체도 복잡하고 이렇게 작성된 프로그램을 이해하는 것도 어렵습니다. 따라서 리스프 프로그래머들은 일반적으로 인자를 수정하지 않고, 인자는 인자, 결과는 결과로 구분된 함수를 작성합니다.</p>
<h2 id="인자는-보통은-함수가-적용-전에-평가된다"><a class="header" href="#인자는-보통은-함수가-적용-전에-평가된다">인자는 (보통은) 함수가 적용 전에 평가된다.</a></h2>
<p>리스프가 함수를 평가하면, 앞서 봤던것처럼[p 42], 항상 모든 인자를 우선적으로 평가합니다. 불행히도, 모든 규칙에는 예외가 있으며, (곧 보게될 것처럼)이 규칙도 예외는 아닙니다... 문제는 리스프가 함수의 인자를 평가하지 않을 수 있다라는 점이 아니라, 리스트 폼은 함수 호출이 아닐 수 도 있다라는 점입니다.</p>
<h2 id="인자들은-좌측에서-우측으로-순서대로-평가된다"><a class="header" href="#인자들은-좌측에서-우측으로-순서대로-평가된다">인자들은 좌측에서 우측으로 순서대로 평가된다</a></h2>
<p>리스트 폼이 함수를 호출하면, 이의 인자는 항상 좌측에서 우측으로 순서대로 평가됩니다.</p>
<h2 id="스페셜-폼과-매크로는-인자의-평가하는-방법을-바꿀-수-있다"><a class="header" href="#스페셜-폼과-매크로는-인자의-평가하는-방법을-바꿀-수-있다">스페셜 폼과 매크로는 인자의 평가하는 방법을 바꿀 수 있다.</a></h2>
<p>리스트 폼이 함수 호출이 아닐 수 도 있다 라고 했는데, 그럼 무엇이 될 수 있을까요?
2가지 경우가 있지만, 결과는 같습니다: 몇몇 인자는 평가되며 몇몇은 평가가 안됩니다. 폼이나 폼이 아니냐에 달려있습니다. 이 예외에 대해서만 알면 됩니다. 다행히도, 대부분의 리스프 시스템은 한두번의 키 입력으로 이에 대한 온라인 문서를 여러분에게 보여줄 것입니다.</p>
<p>모든 인자가 평가되지 않는 폼은 두가지가 있습니다: 스페셜 폼과 매크로. 리스프는 몇몇 스페셜 폼을 미리 정의해 두었습니다. 언어 자체의 주요 기능이기에 여러분만의 스페셜 폼을 추가할 수는 없습니다. 또 리스프는 몇몇 매크로를 미리 정의해두었습니다. 단, 매크로는 저희가 작성할 수 있습니다. 리스프의 매크로를 이용하면 언어의 강력한 힘을 이용하여 우리만의 기능을 추가 할 수 있습니다. 이 장의 뒷 부분에서 간략하게 간단한 매크로를 작성해 볼 것입니다 [p 61]. 20장에서는[p 188] 복잡한 매크로에 대해 다뤄볼 것입니다.</p>
<h2 id="짚고-넘어가기-2"><a class="header" href="#짚고-넘어가기-2">짚고 넘어가기</a></h2>
<ul>
<li>폼(form)</li>
<li>키워드(<code>:</code>)</li>
<li>전위 표기법(prefix notation)</li>
<li><code>atom</code></li>
<li><code>numberp</code></li>
<li><code>NIL</code></li>
<li><code>T</code></li>
<li><code>values</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="레슨-03-스페셜-폼과-매크로에-대한-예제"><a class="header" href="#레슨-03-스페셜-폼과-매크로에-대한-예제">레슨 03. 스페셜 폼과 매크로에 대한 예제</a></h1>
<ul>
<li><a href="https://dept-info.labri.fr/~strandh/Teaching/MTP/Common/David-Lamkins/chapter03-03.html">원문</a></li>
</ul>
<p>이제 스페셜 폼과 매크로에 대해 살펴보도록 하겠습니다. 다음 4개의 레슨들을 거쳐, 가장 기본적인 리스프 데이터 형식, 리스트를 이용하여 간단한 함수를 작성케 해주는 레파토리를 구축할 것입니다. 나머지 장에서는 더욱 복잡한 프로그램 구조와 데이터형식을 다룰 것입니다.</p>
<h2 id="setq"><a class="header" href="#setq">SETQ</a></h2>
<p>이전에, 여러분께 리스프가 심볼 폼을 평가하여 변수의 값을 받온다고 말했습니다. <code>setq</code>는 이 변수의 값을 설정하는 방법을 제공합니다:</p>
<pre><code class="language-lisp">(setq my-name &quot;David&quot;)
;;=&gt; &quot;David&quot;

my-name
;;=&gt; &quot;David&quot;

(setq a-variable 57)
;;=&gt; 57

a-variable
;;=&gt; 57

(setq a-variable :a-keyword)
;;=&gt; :A-KEYWORD
</code></pre>
<p><code>setq</code>의 첫번째 인자는 심볼입니다. 이는 평가되지 않습니다. 두번째 인자는 변수의 값으로 할당됩니다. <code>setq</code>는 마지막 인자의 값을 반환합니다.</p>
<p><code>setq</code>는 심볼 그 자체를 값으로 할당하고자 하기에 첫번째 인자를 평가하지 않습니다. 만일 <code>setq</code>가 첫번째 인자를 평가한다면, (할당될 심볼이 있어야 하기에)해당 인자의 값은 심볼이여야 합니다. <code>set</code> 폼이 그러한 일을 합니다:</p>
<pre><code class="language-lisp">(setq var-1 'var-2)
;;=&gt; VAR-2

var-1
;;=&gt; VAR-2

var-2
;;&gt;| Error: Unbound variable

(set var-1 99)
;;=&gt; 99

var-1
;;=&gt; VAR-2

VAR-2
;;=&gt; 99
</code></pre>
<p>첫번째 폼에서 <code>'</code>을 발견하셨나요? 이것은 다음 폼 <code>var-2</code> 가 평가되는 것을 방지합니다. 이번 레슨 후반에, <code>quote</code>[p 50]를 살펴볼때, 더욱 자세히 설명하도록 하겠습니다.</p>
<p>이번 예제에서는, 우선 <code>var-1</code>의 값을 심볼 <code>var-2</code>로 설정하였습니다. 그 후 <code>var-2</code>의 값을 확인하였고, 아무런 값도 가지지 않았다는 것을 확인하였습니다. 다음으로, (setq가 아닌) <code>set</code>을 이용하여 <code>var-1</code>의 값인 심볼 <code>var-2</code>에 값 99를 할당하였습니다.</p>
<p>사실 <code>setq</code> 폼은 심볼과 값을 번갈아 사용하여 짝수개의 인자를 취할 수 있습니다:</p>
<pre><code class="language-lisp">(setq month &quot;June&quot;
      day   8
      year  1954)
;;=&gt; 1954

month
;;=&gt; &quot;June&quot;

day
;;=&gt; 8

year
;;=&gt; 1954
</code></pre>
<p><code>setq</code>는 좌측에서 우측으로 할당을 수행하고, 맨 우측에 있는 값을 반환합니다.</p>
<h2 id="let"><a class="header" href="#let">LET</a></h2>
<p><code>let</code> 폼은 이전에 봐왔던 것보다 좀 더 복잡해 보입니다. <code>let</code>폼은 중첩된 리스트를 이용하지만, 스페셜 폼은 아니기에 특정 요소만 평가됩니다:</p>
<pre><code class="language-lisp">(let ((a 3)
      (b 4)
      (c 5))
  (* (+ a b) c))
;;=&gt; 35

a
;;&gt;| Error: Unbound variable

b
;;&gt;| Error: Unbound variable

c
;;&gt;| Error: Unbound variable
</code></pre>
<p>위에 있는 <code>let</code> 폼은 심볼 <code>a</code>, <code>b</code>, <code>c</code>의 값을 정의 후, 이를 이용하여 산술 계산을 하였습니다. 또한 이 계산의 결과가 바로 <code>let</code> 폼의 결과입니다. <code>let</code>에서 정의된 변수가 폼을 평가한 후에는 어떠한 값도 지니지 않는다는 점을 주목하시기 바랍니다.</p>
<p>대게, <code>let</code>은 다음과 같이 생겼습니다:</p>
<pre><code class="language-lisp">(let (bindings)
  forms)
</code></pre>
<p>bindings에는 임의의 수의 두개의 원소를 지닌 리스트가 있으며 (각 리스트는 심볼과 값을 지닙니다), forms에는 임의의 수의 리스프 폼이 있습니다. forms의 평가를 위해, bindings에 의해 수립된 값을 이용합니다. <code>let</code>은 마지막 폼에 의해 반환된 값(들)을 반환합니다.</p>
<p>들여쓰기는 <code>let</code>의 동작에 영향을 미치진 않지만, 적절한 들여쓰기는 가독성을 향상시킵니다. 다음 두 동일한 폼을 살펴보시기 바랍니다:</p>
<pre><code class="language-lisp">(let ((p 52.8)
      (q 35.9)
      (r (f 12.07)))
  (g 18.3)
  (f p)
  (f q)
  (g r t))

(let ((p 52.8) (q 35.9) (r (f 12.07))) (g 18.3) (f p) (f q) (g r t))
</code></pre>
<p>첫번째 경우, 들여쓰기로 어떤게 바인딩이며 어떤게 폼인지 명확하게 나타납니다. 독자가 <code>let</code> 폼의 두 부분에서 수행된 서로 다른 규칙에 대해 자세히 알지 못할지라도, 들여쓰기는 차이를 나타냅니다.</p>
<p>두번째경우, 여러분은 어디에서 바인딩이 끝나며 폼이 시작되는지 알고자 한다면, 괄호를 세어야만 할 것입니다. 더욱 안좋은 것은, 들여쓰기의 부제는 <code>let</code> 폼의 두 부분에 의해 수행되는 역활의 차이점에 대해 시각적 단서(visual cues)를 없애버립니다.</p>
<p><code>setq</code>를 이용하여 변수를 정의하고 <code>let</code> 폼에서 동일한 변수 이름을 사용한다면, <code>let</code>을 평가하는 동안 <code>let</code>에 의해 정의된 값이 (<code>setq</code>에 의해 정의된)다른 값을 대체할 것입니다:</p>
<pre><code class="language-lisp">(setq a 89)
;;=&gt; 89

a
;;=&gt; 89

(let ((a 3))
  (+ a 2))
;;=&gt; 5

a
;;=&gt; 89
</code></pre>
<p>좌에서 우로 순서대로 값의 할당이 이루어지는 <code>setq</code>와 달리, <code>let</code>은 모두 동일한 시간에 변수를 바인드합니다.</p>
<pre><code class="language-lisp">(setq w 77)
;;=&gt; 77

(let ((w 8)
      (x w))
  (+ w x))
;;=&gt; 85
</code></pre>
<p><code>let</code>은 <code>w</code>를 8로 <code>x</code>는 w로 바인드 하였습니다. 동일한 시각에 이러한 바인딩이 발생하였으므로 <code>w</code>는 여전히 값 77을 지니게 됩니다.</p>
<p>리스프는 순서대로 바인딩을 수행하는 <code>let*</code>이라는 <code>let</code>의 변종을 지녔습니다.</p>
<pre><code class="language-lisp">(setq u 37)
;;=&gt; 37

(let* ((v 4)
       (u v))
  (+ u v))
;;=&gt; 8
</code></pre>
<h2 id="cond"><a class="header" href="#cond">COND</a></h2>
<p><code>cond</code> 매크로는 조건적으로 리스프 폼을 평가하도록 합니다. <code>let</code>처럼, <code>cond</code>는 폼의 다양한 부분을 구분짓기 위해 괄호를 이용합니다. 이 예제를 살펴보시기 바랍니다:</p>
<pre><code class="language-lisp">(let ((a 1)
      (b 2)
      (c 1)
      (d 1))
  (cond ((eql a b) 1)
        ((eql a c) &quot;First form&quot; 2)
        ((eql a d) 3)))
;;=&gt; 2
</code></pre>
<p>위에 정의된 <code>cond</code> 폼에서 3개의 절을 정의하였습니다. 각 절은 테스트 폼으로 시작하는 리스트이며 원하는 만큼의 바디(body) 폼이 뒷따라 나옵니다. 바디 폼은 테스트가 성공일시 실행되는 코드 입니다. 순차적으로 절이 선택됩니다 - 하나의 테스트가 성공하면 그에 대응하는 바디 폼이 평가되고 그 바디 폼의 마지막 값이 <code>cond</code> 폼의 값이 됩니다.</p>
<p><code>cond</code>는 여러 절을 다룰 수 있기에, 스페셜 폼 <code>if</code>에 비해 범용적입니다.</p>
<p>이제 예제에서 어떤일이 수행되는지 살펴보도록 하겠습니다. 두 인자가 동일하거나, 동일한 숫자면 <code>eql</code> 은 <code>T</code>를 반환합니다(17장[p 174]에서 다루게될 미묘한 다름이 있긴 합니다). 3개의 테스트중 두개만 실행되었습니다. 첫번째 <code>(eql a b)</code>는 <code>NIL</code>을 반환합니다. 그러므로, 1을 포함하는 절은 넘어갑니다. 두번째 절은 <code>(eql a c)</code>를 테스트하며 이는 참입니다. 이 테스트가 <code>NIL</code>이 아닌 값을 반환하기에, 절의 나머지 부분이 평가가 되어, 마지막 폼의 값이 <code>cond</code>의 값으로 반환된 다음, 최종적으로 <code>let</code>의 반환값으로써 반환됩니다. 세번째 절은 이미 이전 절이 선택되었기에 평가되지 않습니다 - 절들은 순서대로 선택됩니다.</p>
<p>관습적으로 <code>cond</code>의 마지막 절의 테스트 폼으로 <code>T</code>를 사용합니다. 이는 다른 절들이 모두 테스트에 실패를 하면 마지막 절의 바디 폼이 평가된다는 것을 보증합니다. 기본 값을 반환하거나 기타 다른 적절한 작업을 수행하기 위해 이 마지막 절을 활용할 수 있습니다. 여기 예제가 있습니다:</p>
<pre><code class="language-lisp">(let ((a 32))
  (cond ((eql a 13)
         &quot;An unlucky number&quot;)
        ((eql a 99)
         &quot;A lucky number&quot;)
        (t
         &quot;Nothing special about this number&quot;)))
;;=&gt; &quot;Nothing special about this number&quot;
</code></pre>
<h2 id="quote"><a class="header" href="#quote">QUOTE</a></h2>
<p>가끔씩 리스프의 평가 규칙을 적용시키지 않고 싶을 때가 있을것입니다.. 이러한 예 중 하나를 꼽자면, 함수 호출의 인자로써 심볼의 값보다 심볼 그 자체를 쓰고 싶을 때입니다:</p>
<pre><code class="language-lisp">(setq a 97)
;;=&gt; 97

a
;;=&gt; 97

(setq b 23)
;;=&gt; 23

(setq a b)
;;=&gt; 23

a
;;=&gt; 23

(setq a (quote b))
;;=&gt; B

a
;;=&gt; B
</code></pre>
<p>차이점은 <code>(setq a b)</code>에서 사용된 <code>b</code>의 <em>값</em> 과 <code>(setq a (quote b))</code>에서의 <em>심볼</em> <code>b</code>입니다.</p>
<p><code>quote</code> 폼은 매우 자주 사용되며, 리스프는 약칭 표기를 제공합니다:</p>
<pre><code class="language-txt">(QUOTE form) == 'form
</code></pre>
<p>리스프는 리더 매크로를 통해 <code>'</code>와 <code>quote</code>를 동일하게 처리합니다. 레슨 12 [p 82]에서 어떻게 여러분만의 리더 매크로를 정의할 수 있는지 간략하게 살펴볼 것입니다.</p>
<h2 id="짚고-넘어가기-3"><a class="header" href="#짚고-넘어가기-3">짚고 넘어가기</a></h2>
<ul>
<li><code>setq</code></li>
<li><code>let</code></li>
<li><code>cond</code></li>
<li><code>'</code>, <code>quote</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="레슨-04-조립과-분해"><a class="header" href="#레슨-04-조립과-분해">레슨 04. 조립과 분해</a></h1>
<ul>
<li><a href="https://dept-info.labri.fr/~strandh/Teaching/MTP/Common/David-Lamkins/chapter03-04.html">원문</a></li>
</ul>
<h2 id="cons"><a class="header" href="#cons">CONS</a></h2>
<p><code>cons</code>는 리스트의 가장 기본적인 구성 요소입니다. 이는 함수므로 이의 인자들을 평가합니다. 리스트를 만들때에는 <code>cons</code>의 두번째 인자로 <code>리스트</code> 혹은 <code>NIL</code>이 들어올것입니다.</p>
<pre><code class="language-lisp">(cons 1 nil)
;;=&gt; (1)

(cons 2 (cons 1 nil))
;;=&gt; (2 1)

(cons 3 (cons 2 (cons 1 nil)))
;;=&gt; (3 2 1)
</code></pre>
<p><code>cons</code>는 새로운 항목을 리스트의 시작 부분에 추가합니다. 비어있는 리스트 <code>( )</code> 는 <code>NIL</code>과 동일하며,</p>
<pre><code class="language-txt">( ) ==  NIL
</code></pre>
<p>따라서 이렇게 작성할 수 있습니다:</p>
<pre><code class="language-lisp">(cons 1 ())
;;=&gt; (1)

(cons 2 (cons 1 ()))
;;=&gt; (2 1)

(cons 3 (cons 2 (cons 1 ())))
;;=&gt; (3 2 1)
</code></pre>
<p>혼란스럽게 느껴진다면, 맞습니다, <code>NIL</code>에는 뭔가 특별한 능력이 있습니다. <code>NIL</code>은 키워드는 아니지만 자기 자신을 상수 값으로 가지는 리스프의 두개의 심볼 중 하나입니다. 또 다른 심볼은 <code>T</code>입니다.</p>
<p><code>( ) == NIL</code>이란 것과 <code>NIL</code>이 스스로 평가된다는 것을 종합해보면, 이는 <code>(quote ())</code>를 <code>()</code>로 쓸 수 있다는 것을 의미합니다. 그렇지 않았다면, 리스프는 빈 리스트를 처리하기 위해 평가 규칙에 예외를 추가해야 했을 것입니다.</p>
<h2 id="list"><a class="header" href="#list">LIST</a></h2>
<p>아마 여러분이 눈치챗다면, 중첩된 <code>cons</code> 폼으로도 리스트가 만들어질 수 있다는 것은 조금 지루할 수 도 있습니다. <code>list</code> 폼은 좀더 명료한 방법으로 동일한 일을 수행합니다:</p>
<pre><code class="language-lisp">(list 1 2 3)
;;=&gt; (1 2 3)
</code></pre>
<p><code>list</code>는 여러 인자를 취할 수 있습니다. <code>list</code>는 함수이기에, 이는 인자를 평가합니다:</p>
<pre><code class="language-lisp">(list 1 2 :hello &quot;there&quot; 3)
;;=&gt; (1 2 :HELLO &quot;there&quot; 3)

(let ((a :this)
      (b :and)
      (c :that))
  (list a 1 b c 2))
;;=&gt; (:THIS 1 :AND :THAT 2)
</code></pre>
<h2 id="first와-rest"><a class="header" href="#first와-rest"><strong>FIRST</strong>와 <strong>REST</strong></a></h2>
<p>리스트가 (첫번째와 나머지) 두 부분으로 만들어졌다고 가정한다면, 여러분은 <code>first</code>와 <code>rest</code> 두 연산자를 이용하여 리스트의 개별 원소들을 얻을 수 있습니다:</p>
<pre><code class="language-lisp">(setq my-list (quote (1 2 3 4 5)))
;;=&gt; (1 2 3 4 5)

(first my-list)
;;=&gt; 1

(rest my-list)
;;=&gt; (2 3 4 5)

(first (rest my-list))
;;=&gt; 2

(rest (rest my-list))
;;=&gt; (3 4 5)

(first (rest (rest my-list)))
;;=&gt; 3

(rest (rest (rest my-list)))
;;=&gt; (4 5)

(first (rest (rest (rest my-list))))
;;=&gt; 4
</code></pre>
<p><code>first</code>와 <code>rest</code> 함수를 이리저리 엮는 것은 분명 지루한 작업일 것입니다. 또, 이러한 접근 법은 프로그램에서 특정 요소만을 선택하고자 할때나 혹은 리스트의 길이가 무한일때 잘 먹히지 않을 것입니다. 4장[p 84] 에서 재귀 함수를 정의할때 이러한 문제를 어떻게 해결하는지 살펴볼 것입니다. 나중에 13장에서 [p 150], 리스프가 제공하는 리스트 혹은 시퀀스 속 요소를 선택할 수 있는 함수들을 살펴 볼 것입니다</p>
<p><code>first</code>와 <code>rest</code>는 꽤 최근 동안 활약해온 <code>car</code>와 <code>cdr</code> 함수의 이름을 바꾸어 리스프에 추가된 것입니다. 초기 리스프 구현체 중 하나에서 <code>car</code>와 <code>cdr</code>의 이름이 유례됬고, 이 이름에 기반한 구현체가 이미 오래전에 바뀌었음에도 불구하고 수십년간 고수되었습니다</p>
<h2 id="짚고-넘어가기-4"><a class="header" href="#짚고-넘어가기-4">짚고 넘어가기</a></h2>
<ul>
<li><code>cons</code></li>
<li><code>list</code></li>
<li><code>first</code></li>
<li><code>rest</code></li>
<li><code>car</code></li>
<li><code>cdr</code></li>
<li><code>nil</code> , <code>( )</code></li>
<li><code>T</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="레슨-05-네이밍과-아이덴티티naming-and-identity"><a class="header" href="#레슨-05-네이밍과-아이덴티티naming-and-identity">레슨 05. 네이밍과 아이덴티티(Naming and Identity)</a></h1>
<ul>
<li><a href="https://dept-info.labri.fr/~strandh/Teaching/MTP/Common/David-Lamkins/chapter03-05.html">원문</a></li>
</ul>
<h2 id="심볼은-단지-이름"><a class="header" href="#심볼은-단지-이름">심볼은 단지 이름</a></h2>
<p>심볼은 단지 이름입니다. 심볼은 심볼 그 자체 입니다. 이는 리스프에서 특정 종류의 프로그램을 작성하는 것을 쉽게 만들어 줍니다. 예를들어, 프로그램으로 가족 관계를 나타내고자 한다면, 이와 같은 관계를 나타내는 데이터베이스를 만들 수 있습니다:</p>
<pre><code class="language-lisp">(father John Barry)
(son John Harold)
(father John Susan)
(mother Edith Barry)
(mother Edith Susan)

...

</code></pre>
<p>각각의 관계를 리스트로 표현했습니다. 예로 <code>(father John Barry)</code>는 <code>John</code>은 <code>Barry의 아버지</code>라는 것을 의미합니다. 데이터베이스 속 리스트의 모든 요소는 심볼입니다. 예를들어 Harold는 Barry의 할아버지라는 것을 판별하기 위해 리스프 프로그램은 이 데이터베이스안에 있는 심볼들을 비교할 수 있습니다.</p>
<p>심볼이 없는 다른 언어 언어에서 이와 같은 프로그램을 작성하고자 한다면, 가족 구성원의 이름과 관계를 어떻게 표현해야할지 결정해야만 해야하며, 거기에 필요한 모든 동작들을 (읽고, 출력하고, 비교하고, 할당하고, 기타등등) 수행하는 코드를 작성해야만 할 것입니다. 이름을 지정하는 데 사용되는 오브젝트들과는 별개의 데이터 타입인 심볼이기에 이 모든 것들이 리스프에 이미 내장되어 있습니다.</p>
<h2 id="심볼은-항상-유니크하다"><a class="header" href="#심볼은-항상-유니크하다">심볼은 항상 유니크하다.</a></h2>
<p>프로그램에서 이름이 같은 심볼은 항상 동일합니다. <code>eq</code> 테스트로 심볼을 비교할 수 있습니다:</p>
<pre><code class="language-lisp">(eq 'a 'a)
;;=&gt; T

(eq 'david 'a)
;;=&gt; NIL

(eq 'David 'DAVID)
;;=&gt; T

(setq zzz 'sleeper)
;;=&gt; SLEEPER

(eq zzz 'sleeper)
;;=&gt; T
</code></pre>
<p>심볼 이름으로 대문자나 소문자를 사용하는 것은 문제가 되지 않습니다. 내부적으로, 리스프는 심볼 이름에 있는 모든 알파벳 문자들을 보통은 대문자로 바꾸며, 리스프 리더 속에 있는 플레그를 설정하여 이 기본 설정을 제어할 수 있습니다.
레슨 10 [p 65](또한 31장 [p 247]참조)에서 패키지에 대해 배운다면, 스펠은 같지만 동일하지는 않는 심볼 이름을 만들 수 있습니다. 지금 알아야 할것은 <code>:</code> 로 표시된 심볼은 특별하게 취급한다 라는 것입니다.</p>
<h2 id="심볼로-값에-이름-붙일-수-있다"><a class="header" href="#심볼로-값에-이름-붙일-수-있다">심볼로 값에 이름 붙일 수 있다.</a></h2>
<p>심볼의 자기 자신을 표현하는 능력 역시 유용하지만, 더욱 일반적으로 사용되는 곳은 값의 이름을 붙일 때입니다. 이는 다른 프로그래밍 언어에서 변수와 함수 이름의 역활을 맡습니다. 리스프 심볼은 값의 이름이나, 함수의 이름을 지을 때 사용됩니다.</p>
<p>리스프에서 특이한 점 중 하나는 심볼은 함수랑 변수의 값을 동시에 지닐 수 있다 라는 점 입니다:</p>
<pre><code class="language-lisp">(setq first 'number-one)
;;=&gt; NUMBER-ONE

(first (list 3 2 1))
;;=&gt; 3

first
;;=&gt; NUMBER-ONE
</code></pre>
<p>첫번째와 마지막 경우에서의 <code>first</code>는 <strong>변수</strong> 이며 , 두번째인 경우는 리스프에 의해 미리 정의된 <strong>함수</strong> 라는 점을 주의깊게 보시길 바랍니다. 리스프는 심볼이 보이는 곳에 기반하여 이 값이 무엇인지 결정합니다. 평가 규칙에 따라 값을 요청받으면, 리스프는 심볼의 변수 값을 찾습니다. 함수를 요청받으면, 리스프는 심볼의 함수 값을 찾습니다.</p>
<p>심볼은 변수나 함수의 값 외에 다른 값을 가질 수 있습니다. 심볼은 문서, 프로퍼티 리스트(property list) 혹은 출력시 표시되는 값을 가질 수 있습니다. 심볼의 문서는 해당 심볼의 설명을 위한 텍스트입니다. <code>documentation</code> 폼을 사용하거나 심볼의 값을 정의하는 몇몇 폼에서 심볼에 대한 문서도 같이 만들 수 있습니다. 심볼은 다양한 의미를 가질 수 있으므로 함수 및 변수와 같이 여러 가지 의미에 맞는 각각에 대한 문서를 만들 수 있습니다.</p>
<p>프로퍼티 리스트는 엔트리(entry)당 하나의 키를 지닌 자그마한 데이터 베이스와 같습니다. 레슨 10 [p 65]에서 이러한 심볼의 사용법을 살펴볼 것입니다.</p>
<p>출력 이름은 리스프에서 심볼을 출력하기 위해 사용하는 것입니다. 일반적으로 이 이름을 변경하지 않는게 좋습니다; 다른 이름으로 변경한다면, 다른 이름으로 출력된 결과를 리스프가 다시 읽어들일때 원래 심볼값과 다른 의미로 받아들여 혼란을 야기할 것입니다.</p>
<h2 id="값은-하나-이상의-이름을-가질-수-있다"><a class="header" href="#값은-하나-이상의-이름을-가질-수-있다">값은 하나 이상의 이름을 가질 수 있다</a></h2>
<p>값은 하나 이상의 이름을 가질 수 있습니다. 즉, 하나 이상의 심볼이 동일한 값을 공유할 수 있다는 것입니다. 다른 언어에서 이러한 방식으로 동작하는 것으로는 포인터가 있습니다. 리스프는 프로그래머에게 포인터를 노출하진 않지만, 공유되어 사용되는 오브젝트들이 있습니다. <code>eq</code> 테스트로 오브젝트가 서로 같은지 확인할 수 있습니다. 다음에 나오는 것을 살펴보시기 바랍니다:</p>
<pre><code class="language-lisp">(setq L1 (list 'a 'b 'c))
;;=&gt; (A B C)

(setq L2 L1)
;;=&gt; (A B C)

(eq L1 L2)
;;=&gt; T

(setq L3 (list 'a 'b 'c))
;;=&gt; (A B C)

(eq L3 L1)
;;=&gt; NIL
</code></pre>
<p>여기서, 동일한 값을 <code>L1</code>과 <code>L2</code>라 이름지엇기에, <code>L1</code>과 <code>L2</code>는 <code>eq</code>합니다. 다시 말하자면 <code>(list 'a 'b 'c)</code> 폼에 의해 생성된 값은 <code>L1</code>과 <code>L2</code>라는 두개의 이름을 갖습니다. <code>(setq L2 L1)</code> 폼은  &quot;L2의 값이 L1의 값이 되도록 해라&quot; 라고 지시합니다. 값의 복사를 말 하는게 아니라, 값 그 자체를 지칭합니다. 따라서 <code>L1</code>과 <code>L2</code>는 동일한 값 (처음 <code>L1</code>에 할당된 리스트 <code>(A B C)</code>)을 공유합니다.</p>
<p>또한 <code>L3</code>도 리스트 <code>(A B C)</code>를 값으로 갖지만, 이는 <code>L1</code>과 <code>L2</code>가 공유하는 것과는 다른 새로운 리스트 입니다. 비록 <code>L3</code>의 값이 <code>L1</code>과 <code>L2</code>의 값과 동일한 것처럼 보이지만, 다른 <code>list</code> 폼에 의해 생성되었기에, 이는 다른 리스트입니다. 따라서, 서로 심볼 <code>A</code>, <code>B</code>, <code>C</code>로 구성된 리스트이지만, 다른 리스트이기에 <code>(eq L3 L1)</code>는 <code>NIL</code>이 됩니다.</p>
<h2 id="짚고-넘어가기-5"><a class="header" href="#짚고-넘어가기-5">짚고 넘어가기</a></h2>
<ul>
<li><code>eq</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="레슨-06-바인딩binding-vs-할당assignment"><a class="header" href="#레슨-06-바인딩binding-vs-할당assignment">레슨 06. 바인딩(binding) vs 할당(Assignment)</a></h1>
<ul>
<li><a href="https://dept-info.labri.fr/~strandh/Teaching/MTP/Common/David-Lamkins/chapter03-06.html">원문</a></li>
</ul>
<h2 id="바인딩은-값을-담을-새로운-공간을-만든다"><a class="header" href="#바인딩은-값을-담을-새로운-공간을-만든다">바인딩은 값을 담을 새로운 공간을 만든다</a></h2>
<p>리스프는 종종, 변수의 값을 담기 위해 새로이 메모리를 할당하여 <strong>바인딩을 만듭니다</strong>. 바인딩은 변수의 렉시컬 스코프(lexical scope) 구현을 위한 매우 일반적인 매커니즘이지만, 바인딩의 라이프타임에 따라 다른 용도로도 사용됩니다. 8장[p 126]에서 라이프타임(lifetime)과 가시성(visibility)를 공부할때 이를 다시 논할 것입니다.</p>
<p>리스프는 새로운 바인딩을 위해 저장공간을 할당합니다. 이것이 끔찍하게 비효율적인 것처럼 보이지만, 아직 리스프가 어디에 저장공간을 할당하는지에 대해서는 알 수 가 없습니다. 예를들어, 리스프는 함수 인자를 값으로 바인드할때, 다른 프로그래밍 언어들처럼 스택(stack)에 저장공간을 할당합니다. 리스프는 바인딩의 라이프타임을 판단할 수 없으면 해당 바인딩을 힙(heap)에 생성합니다.</p>
<h2 id="바인딩은-이름을-가진다"><a class="header" href="#바인딩은-이름을-가진다">바인딩은 이름을 가진다</a></h2>
<p>리스프는 각 바인딩마다 이름을 부여합니다. 만일 그렇지 않다면, 프로그램은 어떻게 바인딩을 참조할 수 있을까요? 간단하게, 어? 잠시만요...</p>
<h2 id="바인딩은-동시에-다른-값을-가질-수-있다"><a class="header" href="#바인딩은-동시에-다른-값을-가질-수-있다">바인딩은 동시에 다른 값을 가질 수 있다.</a></h2>
<p>중첩 바인딩에서 동일한 이름을 공유하는 것은 매우 일반적인 일입니다. 예를들어:</p>
<pre><code class="language-lisp">(let ((a 1))
   (let ((a 2))
      (let ((a 3))
         ...)))
</code></pre>
<p>여기서, (...으로 표시된) 가장 안쪽의 <code>let</code>에 도착할 쯤에는, <code>a</code>는 3개의 서로 다른 바인딩을 가지게 됩니다.</p>
<p>단, 위 예제가 전형적인 리스프 코드라고 말하는 것은 결코 아닙니다.</p>
<h2 id="가장-가까운-바인딩"><a class="header" href="#가장-가까운-바인딩">가장 가까운 바인딩</a></h2>
<pre><code class="language-lisp">;; 여기서는, A는 바인딩 되지 않습니다.

(let ((a 1))
   ;; 여기서 A의 가장 가까운 바인딩은 값 1을 갖습니다.

   (let ((a 2))
      ;; 여기서 A의 가장 가까운 바인딩은 값 2을 갖습니다.

      (let ((a 3))
         ;; 여기서 A의 가장 가까운 바인딩은 값 3을 갖습니다.
         ...)))
</code></pre>
<p>보시다시피, 가장 가까운 바인딩이란 상대적인 위치를 가집니다. 바인딩 폼이 어떻게 중첩되었는지 살펴보면 (위에서 보인것처럼 여러분의 코드를 들여쓰기하였다면 이를 하기에 쉬울 것입니다), 어떻게 프로그램이 바인딩에 접근하는지 알 수 있습니다.</p>
<p>한가지 더 여러분이 알아야 할것은, 내부 바인딩 폼이 동일한 심볼을 바인드하지 않는 한, 내부 바인딩 폼에서도 외부 바인딩이 여전히 유효하다는 점 입니다:</p>
<pre><code class="language-lisp">;; 여기서, A와 B는 바인딩 되지 않습니다.

(let ((a 1)
      (b 9))
   ;; 여기서, A의 가장 가까운 바인딩은 값 1을 지니며,
   ;; B의 바인딩은 값 9를 지닙니다.

   (let ((a 2))
      ;; 여기서, A의 가장 가까운 바인딩은 값 2를 지닙니다.
      ;; B의 바인딩은 여전히 값 9를 지닙니다.
      
      (let ((a 3))
         ;; 여기서, A의 가장 가까운 바인딩은 값 2를 지닙니다.
         ;; B는 여전히 외부의 LET 폼에서의 값 9를 지닙니다.
         ...)))
</code></pre>
<h2 id="이미-만든-바인딩에만-프로그램이-접근할-수-있습니다"><a class="header" href="#이미-만든-바인딩에만-프로그램이-접근할-수-있습니다">이미 만든 바인딩에만 프로그램이 접근할 수 있습니다.</a></h2>
<p>바인딩 폼이 새로운 값을 이미 존재하는 심볼에 바인딩하면, 이전의 값은 가려지게 됩니다. 프로그램이 내부 바인딩 폼을 실행하는 동안에, 외부 바인딩 값이 감춰집니다 (단, 사라지지는 않습니다). 그러나, 프로그램이 내부 바인딩 폼을 빠저나가면, 외부 바인딩 값이 복구됩니다. 예를들어:</p>
<pre><code class="language-lisp">(let ((z 1))
   ;; 여기서, Z의 가장 가까운 바인딩은 값 1을 지닙니다.

   (let ((z 2))
      ;; 여기서, Z의 가장 가까운 바인딩은 값 2을 지닙니다.
      ...)
   
   ;; 이제 여러분은 내부 바인딩 폼을 빠져나왔으며,
   ;; 다시 바인딩 값 1을 보게됩니다.
   ...)
</code></pre>
<h2 id="할당은-오래된-장소에-새로운-값을-줍니다-gives-an-old-place-a-new-value"><a class="header" href="#할당은-오래된-장소에-새로운-값을-줍니다-gives-an-old-place-a-new-value">할당은 오래된 장소에 새로운 값을 줍니다. gives an old place a new value</a></h2>
<p><code>setq</code> 폼은 이미 존재하는 바인딩 값을 바꿉니다:</p>
<pre><code class="language-lisp">(let ((z 1))
   ;; 여기서, Z의 가장 가까운 바인딩은 값 1을 지닙니다.

   (setq z 9)
   ;; 이제 값 Z는 9입니다.

   (let ((z 2))
      ;; 여기서, Z의 가장 가까운 바인딩은 값 2을 지닙니다.
      ...)
   
   ;; 이제 여러분은 내부 바인딩 폼을 빠져나왔으며,
   ;; 다시 Z의 외부 바인딩 값 9을 보게됩니다.
   ...)
</code></pre>
<p>위의 <code>setq</code> 폼은, 바깥쪽 <code>let</code> 폼에서 정의된 <code>z</code>의 바인딩값을 바꿉니다. 이는 종종 좋지 않은 일을 불러옵니다. 문제라고 생각되는 점은 <code>z</code>의 값을 확인하기 위해 살펴봐야만 하는 곳이 이제 두 곳으로 늘어났다는 것입니다 - 첫번째는 바인딩 폼, 그 다음은 <code>setq</code>로 할당한 코드. 들여쓰기를 활용하는 바인딩 폼과는 달리, 프로그램의 본체 부분에서 할당하는 폼에는 따로 들여쓰기가 없습니다; 프로그램을 읽을때 이러한 부분을 찾아내는것이 어렵습니다.</p>
<p>이전 예제에서 봤던것과 같이 새로운 바인딩을 도입하여 매우 쉽게 할당하는 코드를 우회할 수 있습니다.</p>
<pre><code class="language-lisp">(let ((z 1))
   ;; 여기서, Z의 가장 가까운 바인딩은 값 1을 지닙니다.

   (let ((z 9))
      ;; Z의 새 값은 이제 9.

      (let ((z 2))
         ;; 여기서, Z의 가장 가까운 바인딩은 값 2을 지닙니다.
         ...)

      ;; 이제 여러분은 내부 바인딩 폼을 빠져나왔으며,
      ;; 다시 중간에 있는 바인딩 값 9가 Z의 바인딩 값이 됩니다.
      ...)

   ;; 여기서, 가장 바깥쪽 바인딩 값 1이 Z의 바인딩 값이 됩니다.
   ...)
</code></pre>
<p>이제 <code>let</code>폼의 들여쓰기로 인해 <code>z</code>의 모든 바인딩을 알아보기 쉬워졌습니다. 프로그램의 어느 지점에서(예제에서는 ...에서) <code>z</code>의 올바른 바인딩을 찾기 위해 여러분이 해야할 일은 프로그램을 읽을 시 들여쓰기를 주의하여 상위 레벨에 있는 <code>let</code> 폼을 찾아보는 것입니다.</p>
<p><code>let</code> 폼으로 둘러싸여 있지 않는 곳에서 <code>setq</code> 폼이 어떠한 변수를 할당하고 있다면, 이는 전역 변수이거나 특수(special) 변수일 것입니다.</p>
<p>전역 변수는 다른 바인딩으로 가려지지 않는한 어느곳에서나 접근이 가능하며, 리스프 시스템이 동작하는 동안 사용할 수 있습니다. 특수(special) 변수는 8장[p 126]에서 살펴볼 것입니다.</p>
<pre><code class="language-lisp">(setq a 987)
;; 여기서, A는 전역 값 987를 지녔습니다.

(let ((a 1))
   ;; 여기서, A의 바인딩 값 1이 전역 변수의 값을 가리게 됩니다.
   ...)

;; 이제 A의 전역 값이 다시 살아났습니다.

...
</code></pre>
<h2 id="짚고-넘어가기-6"><a class="header" href="#짚고-넘어가기-6">짚고 넘어가기</a></h2>
<ul>
<li>바인딩(binding)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="레슨-07-필수---함수-정의essential-function-definition"><a class="header" href="#레슨-07-필수---함수-정의essential-function-definition">레슨 07. 필수 - 함수 정의(Essential Function Definition)</a></h1>
<ul>
<li><a href="https://dept-info.labri.fr/~strandh/Teaching/MTP/Common/David-Lamkins/chapter03-07.html">원문</a></li>
</ul>
<h2 id="defun---이름을-가진-함수-정의"><a class="header" href="#defun---이름을-가진-함수-정의">DEFUN - 이름을 가진 함수 정의</a></h2>
<p><code>defun</code> 폼을 이용하여 이름을 가진 함수를 정의할 수 있습니다:</p>
<pre><code class="language-lisp">(defun secret-number (the-number)
  (let ((the-secret 37))
    (cond ((= the-number the-secret) 'that-is-the-secret-number)
          ((&lt; the-number the-secret) 'too-low)
          ((&gt; the-number the-secret) 'too-high))))
;;=&gt; SECRET-NUMBER
</code></pre>
<p>레슨 3에서 <code>let</code>, <code>cond</code>, <code>'</code>(quote의 별칭)를 다루었습니다. 숫자 비교 함수들은 그 의미가 명확합니다.</p>
<p><code>defun</code> 폼은 3개의 인자를 가집니다:</p>
<ol>
<li>함수의 이름: <code>secret-number</code></li>
<li>인자 이름 리스트: 이것이 호출되엇을시 함수의 인자가 될 <code>(the-number)</code></li>
<li>함수의 본체: <code>(let ...)</code></li>
</ol>
<p>3개 모두 각각 그 그대로 나타내어야 하므로, <code>defun</code>은 인자를 평가하지 않습니다 (만일 평가가 수행되었다면, 각 인자에 <code>quote</code>를 붙여야만 하는 불편함이 생길 것입니다).</p>
<p><code>defun</code>은 정의된 함수 이름을 반환하고, 여러분이 제공한 이름, 인자 리스트, 본체를 이용하여 함수의 정의를 전역으로 선언합니다. <code>defun</code>을 이용하여 함수를 만들고 나면 바로 이를 사용할 수 있습니다:</p>
<pre><code class="language-lisp">(secret-number 11)
;;=&gt; TOO-LOW

(secret-number 99)
;;=&gt; TOO-HIGH

(secret-number 37)
;;=&gt; THAT-IS-THE-SECRET-NUMBER
</code></pre>
<p>함수를 호출할때, 이것의 인수는(예. 두번쩨 예제에서 <code>99</code>) 정의에서 사용한 인자 이름(즉. <code>the-umber</code>)에 바인딩이 됩니다. 그런 다음, 함수의 본체 (즉. (LET ...))은 해당 인자의 바인딩 컨텍스트로 평가됩니다. 다른 말로 하자면, <code>(SECRET-NUMBER 99)</code>를 평가하는 것은 <code>99</code>가 변수 <code>THE-NUMBER</code>로 바인딩 된체 <code>SECRET-NUMBER</code> 함수 본체를 실행하도록 만들어 줍니다.</p>
<p>물론, 여러분은 하나 이상의 인자를 지닌 함수를 정의 할 수 있습니다.</p>
<pre><code class="language-lisp">(defun my-calculation (a b c x)
  (+ (* a (* x x))
     (* b x)
     c))
;;=&gt; MY-CALCULATION

(my-calculation 3 2 7 5)
;;=&gt; 92
</code></pre>
<p>함수를 호출할때 인수들은 순서에 맞게 인자 이름에 바인딩 됩니다. 리스프는 인자 이름의 리스트는 여러가지 변형들이 있습니다. 공식적으로 이러한 변형 리스트를 람다 리스트라 부릅니다 - 21장[p 198]에서 이것의 다른 기능들에 대해 살펴 볼 것입니다.</p>
<h2 id="lambda---이름-없는-함수-정의"><a class="header" href="#lambda---이름-없는-함수-정의">LAMBDA - 이름 없는 함수 정의</a></h2>
<p>때로는 프로그램에서 단 한곳에서만 쓰이는 함수가 필요할 것입니다. <code>defun</code>으로 함수를 만들어 이를 한번만 호출할 수 있습니다. 그리고 때때로 프로그램을 읽을 때를 도움이 되도록 함수에 잘 짜여진 이름을 부여할 수 도 있습니다. 그러나 종종 여러분이 필요한 함수는 아주 사소하거나 아주 명백하여 이름을 굳이 지을 필요가 없거나, 이전에 같은 이름이 쓰였는지에 대해 걱정하지 않고 싶을 때가 있을 것입니다. 이와 같은 상황에서, 리스프에선 <code>lambda</code> 폼을 이용하여 이름 없는 함수를 만들 수 있습니다. <code>lambda</code> 폼은 마치 이름이 없는 <code>defun</code> 폼처럼 보입니다:</p>
<pre><code class="language-lisp">(lambda (a b c x)
   (+ (* a (* x x))
      (* b x)
      c))
</code></pre>
<p>여기서 <code>lambda</code> 폼을 평가할 수 없습니다; 이는 리스프가 함수 자리라고 예상되어 지는 곳에서만 보여야 합니다 - 보통 폼의 첫번째 요소;</p>
<pre><code class="language-lisp">(lambda (a b c x)
     (+ (* a (* x x))
        (* b x)
        c))
;;&gt;| Error

((lambda (a b c x)
      (+ (* a (* x x))
         (* b x)
         c))
   3 2 7 5)
;;=&gt; 92
</code></pre>
<h2 id="짚고-넘어가기-7"><a class="header" href="#짚고-넘어가기-7">짚고 넘어가기</a></h2>
<ul>
<li><code>defun</code></li>
<li><code>lambda</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="레슨-08-필수---매크로-정의essential-macro-definition"><a class="header" href="#레슨-08-필수---매크로-정의essential-macro-definition">레슨 08. 필수 - 매크로 정의(Essential Macro Definition)</a></h1>
<ul>
<li><a href="https://dept-info.labri.fr/~strandh/Teaching/MTP/Common/David-Lamkins/chapter03-08.html">원문</a></li>
</ul>
<h2 id="defmacro---이름있는-매크로-정의"><a class="header" href="#defmacro---이름있는-매크로-정의">DEFMACRO - 이름있는 매크로 정의</a></h2>
<p><code>defmacro</code> 폼은 <code>defun</code> 폼과 많이 유사합니다 - 이름(name), 인자 리스트(argument list), 그리고 본체(body)를 지닙니다:</p>
<pre><code class="language-lisp">(defmacro name (argument ...)
   body)
</code></pre>
<h2 id="매크로는-값이-아닌-폼을-반환한다"><a class="header" href="#매크로는-값이-아닌-폼을-반환한다">매크로는 값이 아닌 폼을 반환한다</a></h2>
<p>매크로 본체는 평가될 폼을 반환합니다. 다른 말로 하자면, 매크로의 본체로 값이 아닌 폼을 반환하도록 작성해야 합니다. 리스프가 매크로의 호출을 평가할때, 이는 우선 매크로 본체 정의를 평가하고, 첫번째 평가의 결과를 평가합니다 (이에 비해, 함수의 본체는 값을 반환하기 위해 평가됩니다).</p>
<p>다음으로 저희가 알아야 할 대부분의 내용을 설명하는 몇 가지 간단한 매크로들이 있습니다:</p>
<pre><code class="language-lisp">(defmacro setq-literal (place literal)
  `(setq ,place ',literal))
;;=&gt; SETQ-LITERAL

(setq-literal a b)
;;=&gt; B

a
;;=&gt; B

(defmacro reverse-cons (rest first)
  `(cons ,first ,rest))
;;=&gt; REVERSE-CONS

(reverse-cons nil A)
;;=&gt; (B)
</code></pre>
<p><code>setq-literal</code>는 인수가 평가되지 않는다는 점을 제외하면 마치 <code>setq</code>처럼 동작합니다(SETQ는 이의 두번째 인수를 평가한다는 것을 명심하시기 바랍니다). <code>SETQ-LITERAL</code>의 본체는 (&quot;역따옴표&quot;라 불리는) <code>`</code>로 시작하는 폼을 지녔습니다. 따옴표처럼 역따옴표로 묶인 모든 폼의 평가를 억제하지만, 역따옴표 안에서 쉼표가 나타나는 경우는 예외입니다. 쉼표 뒤에 오는 심볼은 평가됩니다.</p>
<p>따라서 위의 <code>(SETQ-LITERAL A B)</code>를 호출함에 있어, 무슨 일이 벌어지는지 여기 나와 있습니다:</p>
<ol>
<li>심볼 <code>A</code>를 <code>PLACE</code>에 바인드한다.</li>
<li>심볼 <code>B</code>를 <code>LITERAL</code>에 바인드한다.</li>
<li>다음 단계를 거처 <code>`(SETQ ,PLACE ',LITERAL)</code> 본체를 평가한다:
<ol>
<li><code>PLACE</code>를 평가하여 심볼 <code>A</code>를 얻는다.</li>
<li><code>LITERAL</code>를 평가하여 심볼 <code>B</code>를 얻는다.</li>
<li>폼 <code>(SETQ A 'B)</code>를 반환한다.</li>
</ol>
</li>
<li>폼 <code>(SETQ A 'B)</code>를 평가한다.</li>
</ol>
<p>반환된 폼에서 역따옴표나 쉼표는 보이지 않습니다. <code>SETQ-LITERAL</code> 호출에서 <code>A</code>나 <code>B</code>가 평가되지 않지만 서로 다른 이유 때문입니다. <code>A</code>는 <code>SETQ</code>의 첫번째 인수이기에 평가되지 않습니다. <code>B</code>는 매크로에 의해 반환된 폼앞에 따옴표(<code>'</code>)가 보이기에 평가되지 않습니다</p>
<p><code>(REVERSE-CONS NIL A)</code>의 동작은 유사합니다:</p>
<ol>
<li>심볼 <code>NIL</code>을 <code>REST</code>에 바인드한다.</li>
<li>심볼 <code>A</code>를 <code>FIRST</code>에 바인드한다.</li>
<li>다음 단계를 거처, <code>`(CONS ,FIRST ,REST)</code> 본체를 평가한다:
<ol>
<li><code>FIRST</code>를 평가하여 심볼 <code>A</code>를 얻는다.</li>
<li><code>REST</code>를 평가하여 심볼 <code>NIL</code>를 얻는다.</li>
<li>폼 <code>(CONS A NIL)</code>를 반환한다.</li>
</ol>
</li>
<li>폼 <code>(CONS A NIL)</code>을 평가한다.</li>
</ol>
<p><code>CONS</code>는 이의 인수들을 평가하며, 매크로 본체에서 두 인자에 따옴표를 붙이지 않았기에, <code>reverse-cons</code>의 두 인수는 평가됩니다. <code>A</code>는 심볼 <code>B</code>로 평가되며, <code>NIL</code>은 자기자신으로 평가됩니다.</p>
<p>여러분이 평가되기전에 매크로 본체가 어떤지 확인하고자 한다면, <code>macroexpand</code> 함수를 이용할 수 있습니다:</p>
<pre><code class="language-lisp">(macroexpand '(setq-literal a b))
;;=&gt; (SETQ A 'B)

(macroexpand '(reverse-cons nil a))
;;=&gt; (CONS A NIL)
</code></pre>
<p><code>macroexpand</code>는 함수이기에 인자를 평가합니다. 때문에 확장시키고자 하는 폼 앞에 따옴표가 있어야 합니다.</p>
<p>일부러 이번 레슨의 예제를 매우 간단한 걸로 놓았으므로, 여러분은 매우 간단 기본 매커니즘을 이해할 수 있을 것입니다. 일반적으로, 매크로는 함수보다 작성하기 힘듭니다 - 20장[p 188]에서 그 이유와 그러한 복잡한 상황을 다룰 수 있는 적절한 기법에 대해 살펴보도록 하겠습니다.</p>
<h2 id="짚고-넘어가기-8"><a class="header" href="#짚고-넘어가기-8">짚고 넘어가기</a></h2>
<ul>
<li><code>defmacro</code></li>
<li><code>macroexpand</code></li>
<li><code>macroexpand-1</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="레슨-09-필수---다중-값essential-multiple-values"><a class="header" href="#레슨-09-필수---다중-값essential-multiple-values">레슨 09. 필수 - 다중 값(Essential Multiple Values)</a></h1>
<ul>
<li><a href="https://dept-info.labri.fr/~strandh/Teaching/MTP/Common/David-Lamkins/chapter03-09.html">원문</a></li>
</ul>
<h2 id="대다수의-폼은-하나의-값만-만든다"><a class="header" href="#대다수의-폼은-하나의-값만-만든다">대다수의 폼은 하나의 값만 만든다</a></h2>
<p>폼은 보통 하나의 값을 반환합니다. 리스프는 여러개의 값을 생성하거나 받을 수 있는 폼을 갖고 있습니다.</p>
<h2 id="values는-여러개의-값을-생성하거나-아무것도-생성하지-않는다"><a class="header" href="#values는-여러개의-값을-생성하거나-아무것도-생성하지-않는다">VALUES는 여러개의 값을 생성하거나 아무것도 생성하지 않는다.</a></h2>
<p><code>values</code> 폼은 0개 이상의 값을 반환합니다:</p>
<pre><code class="language-lisp">(values)
;;=&gt;

(values :this)
;;=&gt; :THIS

(values :this :that)
;;=&gt; :THIS
;;=&gt; :THAT
</code></pre>
<p>폼의 평가에 의해 생성된 여러 라인이으로 얼마나 많은 값이 반환되었는지 보았습니다. 위의 예제에서 3개의 <code>values</code> 폼에서 각각 0개, 1개, 2개의 값을 생성하였습니다.</p>
<p><code>values</code>는 함수이며, 따라서 인자를 평가합니다.</p>
<h2 id="몇몇-특수한-폼은-여러개의-값을-받을-수-있다"><a class="header" href="#몇몇-특수한-폼은-여러개의-값을-받을-수-있다">몇몇 특수한 폼은 여러개의 값을 받을 수 있다.</a></h2>
<p>여러개의 값들을 다룰려면 무엇을 해야할까요? 가장 기본적인 동작으로는 :</p>
<ol>
<li>각 값들을 개별 심볼로 바인드한다</li>
<li>혹은 값들을 리스트로 모은다.</li>
</ol>
<p>각 값들을 개별 심볼로 바인드하기 위해 <code>multiple-value-bind</code>를 이용합니다:</p>
<pre><code class="language-lisp">(multiple-value-bind (a b c) (values 2 3 5)
  (+ a b c))
;;=&gt; 10
</code></pre>
<p>심볼의 갯수보다 더 많은 값을 넘기면, 초과된 값은 무시됩니다:</p>
<pre><code class="language-lisp">(multiple-value-bind (a b c) (values 2 3 5 'x 'y)
     (+ a b c))
;;=&gt; 10
</code></pre>
<p>심볼의 갯수보다 더 적은 값을 넘기면, 나머지 심볼들은 <code>NIL</code>로 바인드됩니다:</p>
<pre><code class="language-lisp">(multiple-value-bind (w x y z) (values :left :right)
     (list w x y z))
;;=&gt; (:LEFT :RIGHT NIL NIL)
</code></pre>
<h2 id="몇몇-폼은-여러값multiple-values그대로-넘긴다"><a class="header" href="#몇몇-폼은-여러값multiple-values그대로-넘긴다">몇몇 폼은 여러값(multiple values)그대로 넘긴다.</a></h2>
<p>몇몇 폼은 새로운 값을 생성하는 것 대신에, 마지막 값을 본체로 넘김니다. 예제는 <code>let</code>, <code>cond</code>, <code>defun</code>, <code>lambda</code>의 본체를 포함합니다.</p>
<pre><code class="language-lisp">(let ((a 1)
      (b 2))
  (values a b))
;;=&gt; 1
;;=&gt; 2

(cond (nil 97)
      (t (values 3 4)))
;;=&gt; 3
;;=&gt; 4

(defun foo (p q)
  (values (list :p p) (list :q q)))
;;=&gt; FOO

(foo 5 6)
;;=&gt; (:P 5)
;;=&gt; (:Q 6)

((lambda (r s) (values r s)) 7 8)
;;=&gt; 7
;;=&gt; 8
</code></pre>
<p>함수와 <code>lambda</code> 본체의 경우엔, &quot;암시적 <code>PROGN</code>&quot;라 불리는 무언것으로부터 다수의 값이 반환되었습니다. 이는, 본체가 다수의 폼을 포함할 수 있으며, 최종적으로 마지막 폼의 값이 반환됩니다.</p>
<p>위와같은 행동을 원할때 <code>progn</code> 스페실 폼을 이용할 수 있습니다. <code>(PROGN form1 form2 ... formN)</code> 은 순서대로 <code>form1</code>부터 <code>formN</code>까지 평가하고, 최종적으로 <code>formN</code>의 값을 반환합니다.</p>
<h2 id="짚고-넘어가기-9"><a class="header" href="#짚고-넘어가기-9">짚고 넘어가기</a></h2>
<ul>
<li><code>values</code></li>
<li><code>multiple-value-bind</code></li>
<li><code>progn</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="레슨-10-프리뷰---다른-데이터-타입a-preview-of-other-data-type"><a class="header" href="#레슨-10-프리뷰---다른-데이터-타입a-preview-of-other-data-type">레슨 10. 프리뷰 - 다른 데이터 타입(A Preview of Other Data Type)</a></h1>
<ul>
<li><a href="https://dept-info.labri.fr/~strandh/Teaching/MTP/Common/David-Lamkins/chapter03-10.html">원문</a></li>
</ul>
<h2 id="리스프는-거의-항상-숫자를-제대로-처리한다"><a class="header" href="#리스프는-거의-항상-숫자를-제대로-처리한다">리스프는 거의 항상 숫자를 제대로 처리한다.</a></h2>
<p>이는 말하기에 이상한 것처럼 들립니다. 컴퓨터는 항상 숫자로 일을 수행하지 않나요?  음, 아니요... 보통은 그렇지 않습니다.</p>
<p>수치 계산은 수많은 방식으로 나뉠 수 있습니다. 가장 큰 문제가 되는 점 중 하나는 소수의 계산이 있습니다 (여러분의 언어가 이를 실수라 부른다면, 그것은 거짓말 입니다). 비쥬얼 어쩌고 혹은 객체 지향 블라블라와 같은 많은 책들 중 대다수가 소수의 계산에 대해 써져있습니다.</p>
<p>소수의 문제는 수학적으로 실수가 아니지만, 종종 실수인양 (잘못) 사용된다는 점입니다.
중요한 문제는 소수를 그렇게 사용한다면, 정확도의 한계를 지니게 된다는 것 입니다 - 소수점 우측 몇개의 자릿수 만큼. 이제, 계산에 사용되는 모든 숫자가 거의 같은 규모라면, 계산의 정확도가 떨어지지 않을 수 도 있을 것입니다. 그러나, 매우 다양한 규모의 숫자들이라면, 소수점 계산은 정확도를 희생할 것입니다.</p>
<p>여러분의 컴퓨터의 소수가 정확하게 소숫점 7자리를 표현할수 있다고 가정해 봅시다. 그러면, 여러분은 <code>1897482.0</code>에 <code>2973225.0</code>를 더하면 완벽히 정확한 답을 얻을 수 있을 것입니다. 그러나, <code>1897482.0</code>에 <code>0.2973225</code>를 더하고자 한다면, 정확한 답은 <code>14</code>자리의 숫자이지만, 여러분의 컴퓨터는 <code>1897482.0</code>을 답으로 할 것입니다.</p>
<p>소수에 관한 또 다른 문제는 더욱 미묘합니다. 프로그램을 작성할때 보통 10진수에 기반하여 수를 사용할 것입니다. 그러나 컴퓨터는 모든 연산을 2진수에 기반하여 수행합니다. 10진수에서 2진수로의 변환은 어떤 &quot;명백히 정확한&quot; 특정 숫자에 대해 재미난 일을 수행합니다. 예를들어, 소수 <code>0.1</code>은 2진수로 변환하면 순환 분수입니다. 컴퓨터는 순환분수에 의해 요구되는 무한한 숫자를 저장하지 못하기에, 정확하게 0.1을 저장할 수 없습니다.</p>
<p>대부분의 컴퓨터 언어에서 정수(자연수) 연산은 또다른 문제를 지닙니다</p>
<ul>
<li>하나의 정수를 담을 수 있는 양수나 음수의 최대치에 제한을 가하는 경향이 있습니다. 따라서, 숫자 하나를 여러분의 언어에 대해 컴퓨터를 다룰 수 있는 가장 큰 정수에 더하고자 한다면, 둘 중 하나가 일어납니다:</li>
</ul>
<ol>
<li>에러로 프로그램이 종료된다, 혹은</li>
<li>굉장히 부정확한 답을 얻는다.(가장 큰 양수에 1을 더한 것은 가장 작은 음수를 만들어 냅니다.)</li>
</ol>
<p>그러면 숫자에 관해 올바른 일을 수행하기 위해 리스프는 어떻게 처리할까요? 무엇보다도, 이 문제가 컴퓨터의 연산에서 나온 것처럼 보입니다. 답은 리스프는 내장 컴퓨터 산술 연산을 바로 사용하지 않는다는 것입니다 - 수학적으로 정확한 특정한 수치 데이터 형식을 추가하였습니다:</p>
<ul>
<li><code>bignum</code>은 무한한 정수이다 (컴퓨터의 메모리의 한계에 달려있다)</li>
<li>유리수는 나눗셈 알고리즘에서 나온 대략적인 소수가 아니라 두 정수의 정확한 몫이다.</li>
</ul>
<p>물론, 리스프 또한 머신 기반 정수와 소수를 지닙니다. 머신에서의 정수를 리스프에서 <code>fixnum</code>라 부릅니다. <code>fixnum</code>의 범위에서 자연수가 떨어지면, 리스프는 이를 머신의 정수로 저장할 것입니다. 그러나, 이게 매우 커지면, 리스프는 자동으로 이를 <code>bignum</code>으로 승격시킬 것입니다.</p>
<p>앞서 리스프는 거의 항상 수에 관해 올바른 일을 수행한다고 말했는데, <code>거의 항상 수학적으로 옳은 수의 표현을 고른다</code> 라는 의미로 말했었습니다:</p>
<pre><code class="language-lisp">(/ 1 3)
;;=&gt; 1/3

(+ (/ 7 11) (/ 13 31))
;;=&gt; 360/341

(defun factorial (n)
  (cond ((= n 0) 1)
        (t (* n (factorial (- n 1))))))
;;=&gt; FACTORIAL

(factorial 100)
;;=&gt; 933262154439441526816992388562667004907159682643816214685
;;   929638952175999932299156089414639761565182862536979208272
;;   23758251185210916864000000000000000000000000
</code></pre>
<p>:TODO(pyoung)
소수를 사용하여 계산을 할 수 도 있지만, 리스프는 정확한 수치 결과를 부정확한 소수로 전환할 수 없기에(여러분은 이에게 소수는 전염된다라고 말해야 합니다) 일단 이를 계산에 도입하면, 전체 계산 결과는 소수를 유지할 것입니다:</p>
<pre><code class="language-lisp">
(float (/ 1 3))
;;=&gt; 0.3333333333333333

(* (float (/ 1 10)) 
   (float (/ 1 10)))
;;=&gt; 0.010000000000000002

(+ 1/100 (* (float (/ 1 10))
            (float (/ 1 10))))
;;=&gt; 0.020000000000000004

(+ 1/100 1/100) ; 이전 계산과 비교하세요
;;=&gt; 1/50

(* 3 7 10.0)
;;=&gt; 210.0

(- 1.0 1)
;;=&gt; 0.0

(+ 1/3 2/3 0.0)
;;=&gt; 1.0

(+ 1/3 2/3)
;;=&gt; 1 ; 이전 계산과 비교하세요
</code></pre>
<p>리스프는 소수를 소수점과 같이, 정수에는 소수점 없이 출력합니다.</p>
<h2 id="문자는-리스프가-읽고-쓸-수-있는-무언가를-제공합니다"><a class="header" href="#문자는-리스프가-읽고-쓸-수-있는-무언가를-제공합니다">문자는 리스프가 읽고 쓸 수 있는 무언가를 제공합니다.</a></h2>
<p>기본적으로 리스프 I/O는 문자를 이용합니다. <code>READ</code>와 <code>WRITE</code> 함수는 문자를 리스프 오브젝트로 그리고 역으로 변환시킵니다. <code>READ-CHAR</code>와 <code>WRITE-CHAR</code>는 단일 문자를 읽고 씁니다.</p>
<pre><code class="language-lisp">(read)
;;&lt;&lt; a \newline
;;=&gt; A

(read)
;;&lt;&lt; #\a \newline
;;=&gt; a

(read-char)
;;&lt;&lt; a
;;=&gt; #\a

(write 'a)
;;&gt;&gt; A
;;=&gt; A

(write #\a)
;;&gt;&gt; #\a
;;=&gt; #\a

(write-char #\a)
;;&gt;&gt; a
;;=&gt; #\a

(write-char 'a)
;;&gt;| Error: Not a character
</code></pre>
<p>위 예에서 새로운 표기를 추가했습니다. <code>;;&lt;&lt;</code> 표시는 <code>READ</code>와 같은 입력함수에 대한 입력을 기다린다는 것을 의미합니다. <code>\newline</code>은 엔터(enter)키에 의해 생성되는 개행문자를 나타냅니다.</p>
<p>값을 반환하는 것(<code>;;=&gt;</code>)과 달리 <code>;;&gt;&gt;</code>는 출력을 나타냅니다.</p>
<p>개행시 <code>read</code>의 입력받는 동작이 종료된다는 것을 알아채셨을 것입니다. <code>READ</code>는 완벽한 리스프 표현식을 구성하고자하는 문자들을 모으기 때문입니다. 레슨 11[p 77]에서 이것에 대해 좀 더 살펴볼 것입니다. 이번 예제에서, <code>READ</code>는 개행으로 종료되는 심볼을 모읍니다. 심볼은 또한 공백, 괄호, 심볼의 일부가 아닌 문자로 종료됩니다.</p>
<p>대조적으로, <code>READ-CHAR</code>는 입력에서 정확히 하나의 문자만 읽습니다. 문자를 받자마자 <code>READ-CHAR</code>는 실행을 완료하고 문자를 반환합니다.</p>
<p>몇몇 리스프 시스템은 어떠한 입력을 받아들이기 전에 리턴(return) 키를 누르도록 요구할 것입니다. 이는 일상적인게 아니며, 환경 설정 변수로 변경 할 수 있습니다 - 여러분이 사용하는 리스프의 제조사와 상담을 하시기 바랍니다.</p>
<p><code>WRITE</code>와 <code>WRITE-CHAR</code>는 둘 다 받은 값을 반환합니다. 값을 출력하는 방식은 다릅니다. <code>WRITE</code>는 값을 출력하므로, 동일한 값을 생성하는 <code>READ</code>로 표현할 수 있습니다. <code>WRITE-CHAR</code>는, 이것이 <code>READ</code>에서의 문자라는 것을 나타내는 추가 리스프 문법 (<code>#\</code>)가 없는, 읽을 수 있는 문자를 출력합니다.</p>
<p>리스프는 단일 문자를 <code>#\문자</code> 표기법을 이용하여 나타내며, 그러한 문자로는 literal 문자나 출력 가능한 상형문자가 아닌 문자의 이름이 있습니다.</p>
<div class="table-wrapper"><table><thead><tr><th>Character</th><th>Hex Value</th><th>Lisp</th><th>Standard?</th></tr></thead><tbody>
<tr><td>space</td><td>20</td><td>#\Space</td><td>yes</td></tr>
<tr><td>newline</td><td>--</td><td>#\Newline</td><td>yes</td></tr>
<tr><td>backspace</td><td>08</td><td>#\Backspace</td><td>semi</td></tr>
<tr><td>tab</td><td>09</td><td>#\Tab</td><td>semi</td></tr>
<tr><td>linefeed</td><td>0A</td><td>#\Linefeed</td><td>semi</td></tr>
<tr><td>formfeed</td><td>0C</td><td>#\Page</td><td>semi</td></tr>
<tr><td>carriage return</td><td>0D</td><td>#\Return</td><td>semi</td></tr>
<tr><td>rubout or DEL</td><td>7F</td><td>#\Rubout</td><td>semi</td></tr>
</tbody></table>
</div>
<p><code>#\Space</code>와 <code>#\Newline</code>만이 모든 리스프 시스템에서의 요구사항입니다. ASCII 문자셋를 이용하는 시스템은 아마 위에 나온 나머지 문자코드를 구현할 것입니다. <code>\#Newline</code> 문자는 호스트 시스템에 맞는 출력 라인의 끝을 표시하는 컨벤션(convention)을 따릅니다. 예로:</p>
<div class="table-wrapper"><table><thead><tr><th>System</th><th>Newline</th><th>Hex Value</th></tr></thead><tbody>
<tr><td>Macintosh</td><td>CR</td><td>0D</td></tr>
<tr><td>MS-DOS</td><td>CR LF</td><td>0D 0A</td></tr>
<tr><td>Unix</td><td>LF</td><td>0A</td></tr>
</tbody></table>
</div>
<p>94개의 출력가능한 표준 문자들이 <code>\#문자</code>로 표현됩니다:</p>
<pre><code class="language-txt">  ! &quot; # $ % &amp; ' ( ) * + , - . /
0 1 2 3 4 5 6 7 8 9 : ; &lt; = &gt; ?
@ A B C D E F G H I J K L M N O
P Q R S T U V W X Y Z [ \ ] ^ _
‘ a b c d e f g h i j k l m n o
p q r s t u v w x y z { | } ~
</code></pre>
<h2 id="arrays-organize-data-into-tables"><a class="header" href="#arrays-organize-data-into-tables">Arrays organize data into tables</a></h2>
<p>여러분이 데이터를 2차원, 3차원 혹은 더 많은 차원의 테이블로 역으려한다면, 배열(array)을 만들 수 있습니다:</p>
<pre><code class="language-lisp">(setq a1 (make-array '(3 4)))
;;=&gt; #2A((NIL NIL NIL NIL)
;;       (NIL NIL NIL NIL)
;;       (NIL NIL NIL NIL))

(setf (aref a1 0 0) (list 'element 0 0))
;;=&gt; (ELEMENT 0 0)

(setf (aref a1 1 0) (list 'element 1 0))
;;=&gt; (ELEMENT 1 0)

(setf (aref a1 2 0) (list 'element 2 0))
;;=&gt; (ELEMENT 2 0)

a1
;;=&gt; #2A(((ELEMENT 0 0) NIL NIL NIL)
;;       ((ELEMENT 1 0) NIL NIL NIL)
;;       ((ELEMENT 2 0) NIL NIL NIL))

(aref a1 0 0)
;;=&gt; (ELEMENT 0 0)

(setf (aref a1 0 1) pi)
;;=&gt; 3.141592653589793

(setf (aref a1 0 2) &quot;hello&quot;)
;;=&gt; &quot;hello&quot;

(aref a1 0 2)
;;=&gt; &quot;hello&quot;
</code></pre>
<p>dimensions의 리스트를 취하여 배열을 반환하는 MAKE-ARRAY를 이용하여 배열을 만듭니다. 기본적으로,  배열은 어떠한 종류의 데이터라도 담을 수 있습니다; 효율성을 위해 추가 인자로 데이터형식의 요소를 제한할 수 있습니다.</p>
<p>배열의 rank는 dimension의 수와 동일합니다. 위 예제에서 저희는 2-차원rank-2 배열을 만들었습니다. 리스프는 <code>#rankA(...)</code>표기법을 이용하여 배열을 출력합니다. 배열의 내용물은, 첫번째 dimension이 최상단 그룹의 요소로 보여지고, 마지막 dimension이 최하단 그룹의 요소로 보여지는, 중첩된 list로 보여집니다.</p>
<p>여러분의 리스프 시스템은 아마도 여기서 보여졌던것 처럼 라인을 넘기면서 배열을 출력하지 않을 것입니다. 저는 배열의 구조를 강조하기 위해 라인을 넘겼습니다.</p>
<p>배열의 요소를 받기 위해선, AREF를 이용합니다. AREF의 첫번째 요소는 배열입니다; 나머지 요소는 각 dimension의 index를 지정합니다. index의 수는 배열의 rank와 맞아야만 합니다.</p>
<p>배열의 요소를 설정하기 위해선, 이 예제에서 보인것 처럼 SETF form내부에서 AREF를 사용합니다. SETF는 SETQ와 유사하지만, SETQ가 값을 심볼에게 할당하고, SETF는 값을 place에 할당합니다. 예제에서 AREF 폼은 배열의 요소의 place를 지정합니다.</p>
<h2 id="백터는-일차원-배열"><a class="header" href="#백터는-일차원-배열">백터는 일차원 배열</a></h2>
<p>Vector는 일-차원one-dimensional 배열입니다. MAKE-ARRAY를 이용하여 벡터를 만들 수 있으며, AREF를 이용하여 이의 요소에 접근 할 수 있습니다.</p>
<pre><code class="language-lisp">(setq v1 (make-array '(3)))
;;=&gt; #(NIL NIL NIL)

(make-array 3)
;;=&gt; #(NIL NIL NIL)

(setf (aref v1 0) :zero)
;;=&gt; :ZERO

(setf (aref v1 1) :one)
;;=&gt; :ONE

(aref v1 0)
;;=&gt; :ZERO

v1
;;=&gt; #(:ZERO :ONE NIL)


;; 리스프는 #1A(...)이 아닌 조금 간소화된 form #(...)을 이용하여 벡터를 출력합니다.
;; MAKE-ARRAY에서 단일-원소 리스트나 벡터의 차원dimenion을 지정할 수 있습니다.
;; VECTOR 폼을 이용하여 값을 나열하여 벡터를 만들 수 있습니다:
(vector 34 22 30)
;;=&gt; #(34 22 30)
</code></pre>
<p>결과값이 list가 아닌 vector라는 점을 제외하면, 이는 LIST form과 유사합니다. list와 vector간에는 또 다른 닮음이 있습니다: 모두 sequence입니다. sequence는 13장[p 150]에서 보게될 함수에 의해 다뤄집니다.</p>
<p>벡터의 요소에 접근하기 위해 AREF를 이용하거나, sequence-특화 함수 ELT를 이용할 수 있습니다:</p>
<pre><code class="language-lisp">(setf v2 (vector 34 22 30 99 66 77))
;;=&gt; #(34 22 30 99 66 77)

(setf (elt v2 3) :radio)
;;=&gt; :RADIO

v2
;;=&gt; #(34 22 30 :RADIO 66 77)
</code></pre>
<h2 id="문자열은-문자를-담고있는-백터"><a class="header" href="#문자열은-문자를-담고있는-백터">문자열은 문자를 담고있는 백터</a></h2>
<p>여러분은 이미 &quot;...&quot;를 이용한 문자열(string) 작성하는 법을 알고 있습니다. 문자열은 벡터이기에, 문자열의 요소에 접근하기 위해 배열과 백터 함수를 적용할 수 있습니다. 또한 <code>make-string</code> 함수를 이용하여 문자열을 만들거나, <code>string</code> 함수를 이용하여 문자나 심볼을 문자열로 바꿀 수 있습니다.</p>
<pre><code class="language-lisp">(setq s1 &quot;hello, there.&quot;)
;;=&gt; &quot;hello, there.&quot;

(setf (elt s1 0) #\H))
;;=&gt; #\H

(setf (elt s1 12) #\!)
;;=&gt; #\!

s1
;;=&gt; &quot;Hello, there!&quot;

(string 'a-symbol)
;;=&gt; &quot;A-SYMBOL&quot;

(string #\G)
;;=&gt; &quot;G&quot;
</code></pre>
<h2 id="symbols-are-unique-but-they-have-many-values"><a class="header" href="#symbols-are-unique-but-they-have-many-values">Symbols are unique, but they have many values</a></h2>
<p>레슨 5에서 심볼은 고유한 독자성(identity)을 지닌다고 보았지만, 이는 반복성을 지닙니다: 심볼은 같은 철자의 다른 심볼과 동일합니다(이번 레슨 끝부분에서 좀더 배우게될 패키지 designation를 포함하여). 이는 리스프로 하여금 프로그램이나 데이터를 읽어올 수 있게 만들 수 있다는 것을 의미하며, 같은 철자로 나타낸 모든 심볼은 동일한 심볼입니다. 리스프가 이를 수행하는 매커니즘을 제공하기에, 심볼릭 정보를 다루는 프로그램을 작성하는 것에 대한 걱정을 하나 덜게되었습니다.</p>
<p>저희는 또한 레슨 5에서 심볼은 변수와 함수, 그리고 문서, 출력 이름, 프로퍼티(properties)를 위한 값을 가질 수 있다고 배웠습니다. 심볼의 프로퍼티 리스트(property list)는 다수의 키/값 쌍이 심볼과 연결된 아주 작은 데이터베이스와 같습니다. 예를들어, 여러분의 프로그램이 오브젝트를 표현하고 다룬다면, 오브젝트에 관한 정보를 프로퍼티 리스트에 저장할 수 있습니다:</p>
<pre><code class="language-lisp">(setf (get 'object-1 'color) 'red)
;;=&gt; RED

(setf (get 'object-1 'size) 'large)
;;=&gt; LARGE

(setf (get 'object-1 'shape) 'round)
;;=&gt; ROUND

(setf (get 'object-1 'position) '(on table))
;;=&gt; (ON TABLE)

(setf (get 'object-1 'weight) 15)
;;=&gt; 15

(symbol-plist 'object-1)
;;=&gt; (WEIGHT 15 POSITION (ON TABLE) SHAPE ROUND SIZE LARGE COLOR RED)

(get 'object-1 'color)
;;=&gt; RED

object-1
;;&gt;| Error: no value
</code></pre>
<p><code>OBJECT-1</code>은 값을 갖지 않는다는 점을 주목하시기 바랍니다 - 모든 유용한 정보는 두 곳에 있습니다: 심볼의 identify와 심볼의 프로퍼티.</p>
<p>이러한 프로퍼티의 이용은 현대의 오브젝트 프로그래밍보다 몇 십년이나 앞서 나왔습니다. 이는 오브젝트의 필수적인 3가지 매커니즘중 2가지를 제공합니다: 식별자identify와 캡슐화encapsulation (property 값 역시 함수가 될 수 있다는 것을 명심하시기 바랍니다). 3번째 매커니즘, 상속(inheritance)은 다른 &quot;object&quot;를 link하여 simulate합니다.</p>
<p>프로퍼티는 오늘날의 리스프 프로그램에서 거의 사용되지 않습니다. 해쉬테이블(Hashtables) (아래 참조) [p 73] , (다음 section에서 기술된) 구조체(structures), CLOS 오브젝트(7장 [p 117]과 14장 [p 157] 참조)는 사용하기 더 편리하며 더욱 효율적인 방식으로 프로퍼티 리스트의 모든 기능을 제공합니다. 현대 리스프 개발 시스템은 프로퍼티 파일과 심볼을 정의하는 폼의 파일 위치, 함수의 인자 리스트의 정의와 같은 (프로그래밍 환경에서 유용한 도구로 이용하기 위한) 특정 정보를 기록하여 프로그램에 주석을 다는 목적으로 주로 사용합니다.</p>
<h2 id="structures-let-you-store-related-data"><a class="header" href="#structures-let-you-store-related-data">Structures let you store related data</a></h2>
<p>리스프 구조체는, 명명된 슬롯(slot)과 관계된 데이터를 저장하는, 오브젝트를 생성하는 방법을 여러분에게 제시합니다.</p>
<pre><code class="language-lisp">(defstruct struct-1
  color
  size
  shape
  position
  weight)
;;=&gt; STRUCT-1

(setq object-2 (make-struct-1
                              :size 'small
                              :color 'green
                              :weight 10
                              :shape 'square))
;;=&gt; #S(STRUCT-1 :COLOR    GREEN
;;               :SIZE     SMALL 
;;               :SHAPE    SQUARE
;;               :POSITION NIL
;;               :WEIGHT   10)

(struct-1-shape object-2)
;;=&gt; SQUARE

(struct-1-position object-2)
;;=&gt; NIL

(setf (struct-1-position object-2) '(under table))
;;=&gt; (UNDER TABLE)

(struct-1-position object-2)
;;=&gt; (UNDER-TABLE)
</code></pre>
<p>이 예에서, 저희는 <code>COLOR</code>, <code>SHAPE</code>, <code>SIZE</code>, <code>WEIGHT</code> 슬롯을 지닌 <code>STRUCT-1</code> 구조체를 정의하였습니다. 그런 다음 <code>STRUCT-1</code>의 인스턴스(instance)를 만들고, 해당 인스턴스를 변수 <code>OBJECT-2</code>에 할당하였습니다. 예제의 나머지 부분은, struct-slot 이름으로된 접근자(assessor) 함수를 이용하여, 어떻게 구조체 인스턴스의 슬롯에 접근하는지를 보여줍니다. 리스프는 <code>DEFSTRUCT</code>를 이용하여 구조체를 정의할때 <code>make-structname</code>과 structname-slotname 함수를 생성합니다.</p>
<p>6장[p 112]에서 <code>DEFSTRUCT</code>의 optional 기능에 대해 살펴볼 것입니다.</p>
<h2 id="type-information-is-apparent-at-runtime"><a class="header" href="#type-information-is-apparent-at-runtime">Type information is apparent at runtime</a></h2>
<p>심볼은 런타임시 어떠한 변수 타입과도 연관지을 수 있습니다. 이것이 문제되는 경우에 대해, 리스프는 저희에게 값의 타입을 묻는것을 허용합니다</p>
<pre><code class="language-lisp">(type-of 123)
;;=&gt; FIXNUM

(type-of 123456789000)
;;=&gt; BIGNUM

(type-of &quot;hello, world&quot;)
;;=&gt; (SIMPLE-BASE-STRING 12)

(type-of 'fubar)
;;=&gt; SYMBOL

(type-of '(a b c))
;;=&gt; CONS
</code></pre>
<p><code>TYPE-OF</code> 는 인자의 타입을 나타내는 심볼이나 리스트를 반환합니다. 게다가 이 정보는 인자의 종류의 기반하는 프로그램의 행동을 설명하는데 이용할 수 있습니다. <code>TYPECASE</code> 함수는 타입에 대한 질의(inquiry)와 COND-와같은 분기(dispatch)를 결합한 것입니다.</p>
<p>CLOS(14장 [p 157] 참조)S의 제네릭 함수의 도입으로, <code>TYPE-OF</code>는 예전만큼 중요하지는 않습니다.</p>
<h2 id="hash-tables-provide-quick-data-access-from-a-lookup-key"><a class="header" href="#hash-tables-provide-quick-data-access-from-a-lookup-key">Hash Tables provide quick data access from a lookup key</a></h2>
<p>해쉬 테이블은 값과 유니크 키(유일 키, unique key)와 관련있습니다. 프로퍼티 리스트완 다르게, 해쉬 테이블은 엄청나게 많은 키/값쌍에 매우 적합하지만, 작은 연관 set에 대해 엄청난 오버헤드(overhead)를 감수해야합니다.</p>
<pre><code class="language-lisp">(setq ht1 (make-hash-table))
;;=&gt; #&lt;HASH-TABLE&gt;

(gethash 'quux ht1)
;;=&gt; NIL
;;=&gt; NIL

(setf (gethash 'baz ht1) 'baz-value)
;;=&gt; BAZ-VALUE

(gethash 'baz ht1)
;;=&gt; BAZ-VALUE
;;=&gt; T

(setf (gethash 'gronk ht1) nil)
;;=&gt; NIL

(gethash 'gronk ht1)
;;=&gt; NIL
;;=&gt; T
</code></pre>
<p><code>MAKE-HASH-TABLE</code>을 이용하여 해쉬 테이블을 생성하며, <code>GETHASH</code>를 이용하여 값에 접근합니다. <code>GETHASH</code>는 두개의 값을 반환합니다. 첫번째는 키와 관련있는 값입니다. 두번째는 키를 찾으면 <code>T</code>, 아니면 <code>NIL</code>입니다. 위 예제에서 처음과 마지막 <code>GETHASH</code>폼의 차이를 주목하시기 바랍니다.</p>
<p>기본적으로, 해쉬테이블은 <code>EQ</code>(이는 숫자나 리스트가 아닌 심볼에 대해서만 동작합니다)를 이용하여 이의 키를 비교하기 위해 만들어졌습니다. 17장[p 174]에서 동일성 판단(equality predicates)에 대해 더 자세히 배울 것입니다. 지금은, 다수의 키를 이용하고자 한다면, 이 폼을 이용하여 해쉬테이블을 만들어야한다는 것을 명심하시기 바랍니다:</p>
<pre><code class="language-lisp">(make-hash-table :test #'eql)
</code></pre>
<p>리스트를 키로 사용하고자 한다면, 이렇게 해쉬테이블을 만듭니다:</p>
<pre><code class="language-lisp">(make-hash-table :test #'equal)
</code></pre>
<p>키를 없애고자한다면, <code>(REMHASH key hash-table)</code>폼을 이용합니다. 그리고 키에 해당하는 값을 바꾸고자한다면, 키/값쌍을 추가했던것처럼 <code>GETHASH</code>와 <code>SETF</code>를 이용합니다.</p>
<h2 id="packages-keep-names-from-colliding"><a class="header" href="#packages-keep-names-from-colliding">Packages keep names from colliding</a></h2>
<p>프로그램을 작성하는것에 관한 어려운 일중 하나는 프로그램의 이름을 짓는 부분입니다. 한편으론, 기억하기 쉽고 명명된 object의 규칙과 목적을 환기evocative시켜주는 이름을 이용하기 원할 것입니다. 다른 한편으론, 언젠가 여러분의 프로그램과 작업하게될, 다른 프로그램의 어딘가에 이미 사용한 (혹은 사용될 것 같은)이름을 이용하지 않길 원할 것입니다.</p>
<p>이름 충돌(naming conflict)을 피하는 법 중 하나는 프로그램에 있는 모든 이름에 누구도 사용하지 않는 고유 접두사(prefix)를 붙이는 것입니다. 여러분은 이것이 라이브러리에 매번 필요하다고 생각할 것입니다 - 보통 하나에서 세개정도 문자의 접두사가 있다. 불행히도, 여전히 두 소프트웨어 개발자가 동일한 prefix를 선택하기 위한 많은 관문이 남아있습니다; 유달히 몇몇 prefix들이 다른 것보다 더욱 evocative하기 때문입니다. 여러분이 생산한 모든 소프트웨어를 제어하고자 한다면, 모든 prefix를 선택하고 문제를 피할 수 있습니다. prefix naming scheme을 이용하는 third-parfy 소프트웨어를 사고자 한다면, 제조사에 의해 선택된 이름에 관련된 일을 해야할 것이며, 두 제조사가 우연히 동일한 prefix를 사용하지 않기를 희망할 것입니다.</p>
<p><img src="ch03/../res/prefixed-names..gif" alt="prefixed-names.gif" /></p>
<p>이름 충돌을 피하는 또 하나의 방법은 qualified name을 이용하는 것입니다. 이를 하기 위해선, 언어가 프로그래머에 의해 정의되고 제어되는 분리된 이름공간의 지원을 제공해야 합니다. 어떻게 이것이 동작하는지 이해하기 위해, 프로그램을 위해 여러분이 만든 모든 이름이 여러분의 이름이 타이틀 상단에 쓰여진 한장에 종이에 작성되었다고 상상해보시기 바랍니다. 이름이 이용하기에 안전한지 확인하기 위해선, 여러분이 이 페이지에 작성한 이름 목록을 확인하기만 하면 됩니다. 누군가의 소프트웨어가 여러분의 프로그램의 서비스를 필요로 할때, 그것은 여러분의 qualifier와 name을 이용하여 여러분의 이름을 참조합니다. 다른이의 소프트웨어는 다른 qualifier를 지니고 그들의 qualifier는 그들만의 name을 암시하기에(이것을 작성할 필요는 없습니다), 이름 충돌을 피할 방도가 없습니다.</p>
<p>여러분은 qualifier는 이름에 prefix를 붙이기 위한 복잡한 방법에 지나지 않는다고 생각할 것입니다. 그러나, 거기엔 미묘하며 중대한 차이점이 있습니다. prefix는 이름의 일부입니다; 이는 한번 작성되면 바뀔 수 없습니다. qualifier는 이가 qualify한 이름에서 분리되었으며, 정확히 한 장소에서 &quot;작성&quot;되었습니다. 더욱이, 여러분은 이름들이 쓰여진 &quot;종이&quot;를 가리켜 이를 &quot;그러한 이름들&quot;이라 말할 수 있습니다. 다른 프로그래머와 동일한 qualifier를 선택하게 된다면, 여러분은 여전히 여러분이 선택한 qualifier에 의해 &quot;그 이름&quot;을 참조할 수 있습니다 - 다른 말로 하자면, 여러분이 사용할 소프트웨어가 출고된 후에도, 여러분은 qualifier를 바꿀 수 있습니다.</p>
<p><img src="ch03/../res/rename-package.gif" alt="rename-package.gif" /></p>
<p>위 예제에는, 파일 LIB1과 LIB2에서 가져온 두 라이브러리가 있습니다. 두 라이브러리 설계자는, 리스프에서 패키지 이름으로 알려진, 이름 공간namespace을 위해 UTIL이란 이름을 사용하였습니다. 각 라이브러리는 client에게 보여지는 이름들을 나열했습니다. 두 라이브러리를 이용하는 프로그래머는 <code>MY-PACKAGE</code>란 패키지 이름에서 코드를 작성합니다. 각 라이브러리를 로드한후, 프로그래머는 이의 package의 이름을 다른 이름으로 바꿉니다. 그러면, <code>UTIL-1:INITIALIZE</code>와 <code>UTIL-2:INITIALIZE</code>의 호출에서 봤던 것처럼, 라이브러리에 있는 이름들은 이름이 바뀐 qualifier를 이용하여 참조됩니다. 프로그래머는 여전히 qualify 폼이 아닌 INITIALIZE 이름은 이용할 수 있다는 것을 주목하시기 바랍니다 - 이는 <code>MY-PACKAGE:INITIALIZE</code>와 동일합니다.</p>
<p>리스프는 package facility라 알려진 함수와 매크로를 통해 이러한 기능을 제공합니다. <code>DEFPACKAGE</code> 매크로는 간편하게 대부분의 패키지 연산을 제공하는데 반해, <code>IN-PACKAGE</code> 매크로는 현재 패키지를 설정합니다:</p>
<pre><code class="language-lisp">;;;; file: util1.lisp
(defpackage util1
  (:export init func1 func2)
  (:use common-lisp))
(in-package util1)

(defun init () 'util1-init)
(defun func1 () 'util1-func1)
(defun func2 () 'util1-func2)
</code></pre>
<pre><code class="language-lisp">;;;; file: util2.lisp
(defpackage util2
  (:export init func1 func2)
  (:use common-lisp))
(in-package util2)

(defun init () 'util2-init)
(defun func1 () 'util2-func1)
(defun func2 () 'util2-func2)
</code></pre>
<pre><code class="language-lisp">;;;; file: client.lisp
(defpackage client
  (:use common-lisp)
  (:import-from util1 func1)
  (:import-from util2 func2))
(in-package client)

(defun init () 'client-init)

(util1:init)
(util2:init)
(init)
(func1)
(func2)
</code></pre>
<p>예제는 세개의 파일의 내용물을 나열했습니다. File 1과 File 2는 모두 동일한 이름으로 3개의 함수를 정의하였습니다. File 1은 이름을 UTIL1 package에 넣었으며, File 2는 UTIL2 package를 이용합니다. <code>defpackage</code> 폼은 package의 이름을 지어줍니다. <code>:use</code> 옵션은 다른 pakcage에서 qualification없이 사용될 이름을 지정하는 반면, :EXPORT 옵션은 package에서 client에게 노출될 이름을 지정합니다.</p>
<p><code>defpackage</code> 폼은 단지 pakcage를 생성합니다. <code>use-package</code> 폼은 package를 current로 만듭니다 -  qualify가 되지 않은 모든 이름들은 current입니다. COMMON-LISP:<em>PACKAGE</em> 변수는 항상 current package를 포함합니다.</p>
<p>File 3은 CLIENT package를 만듭니다. :INFORT-FROM 옵션은 UTIL1과 UTIL2 package로부터 특정 이름을 가져옵니다 - 이러한 이름들은 CLIENT package에서 qualification 없이 사용되어집니다. UTIL1나 UTIL2에서 export되었지만 CLIENT에서 import된 이름들은, form pakcage:name 의 명시적explicit qualifier를 이용하여 CLIENT에 의해 참조될 수 있습니다.</p>
<p>이번 section에선 아주 기초적인 package 연산만을 다루었습니다. 31장[p 247]에서, 큰 규모의 소프트웨어 시스템을 구성에서의 package를 살펴볼때, 좀더 세부적인걸 다룰 것입니다.</p>
<h2 id="짚고-넘어가기-10"><a class="header" href="#짚고-넘어가기-10">짚고 넘어가기</a></h2>
<ul>
<li><code>read</code></li>
<li><code>write</code></li>
<li><code>read-char</code></li>
<li><code>write-char</code></li>
<li><code>make-array</code></li>
<li><code>aref</code></li>
<li><code>vector</code></li>
<li><code>elt</code></li>
<li><code>string</code></li>
<li><code>type-of</code></li>
<li><code>make-hash-table</code></li>
<li><code>gethash</code></li>
<li><code>remhash</code></li>
<li><code>defstruct</code></li>
<li><code>defpackage</code></li>
<li><code>in-package</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="레슨-11-필수---입력과-출력essential-input-and-output"><a class="header" href="#레슨-11-필수---입력과-출력essential-input-and-output">레슨 11. 필수 - 입력과 출력(Essential Input and Output)</a></h1>
<ul>
<li><a href="https://dept-info.labri.fr/~strandh/Teaching/MTP/Common/David-Lamkins/chapter03-11.html">원문</a></li>
</ul>
<h2 id="read는-리스프-데이터를-받는다"><a class="header" href="#read는-리스프-데이터를-받는다">READ는 리스프 데이터를 받는다.</a></h2>
<p>레슨 10에서 봤던것처럼, <code>read</code>는 문자를 리스프 데이터로 변환시킵니다. 이제까지, 우리들은 리스프 데이터 여러 출력 값들을 보았습니다:</p>
<ul>
<li>심볼과 숫자</li>
<li>문자, 문자열, 리스트, 배열, 백터, 구조체</li>
<li>해쉬태이블</li>
</ul>
<p>리스프 리더는 문자의 분류법(classifications)를 따라 일을 수행합니다. 표준 분류법은 아래에 나와있습니다. 레슨 12에서 보게될 것처럼, 여러분은 필요에 따라 이러한 분류법을 바꿀 수도 있습니다.</p>
<pre><code class="language-txt">표준 구성 문자(Standard Constituent Characters)
-------------------------------
a b c d e f g h i j k l m n o p q r s t u v w x y z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
0 1 2 3 4 5 6 7 8 9
! $ % &amp; * + - . / : &lt; = &gt; ? @ [ ] ^ _ { } ~
&lt;backspace&gt; &lt;rubout&gt;


표준 종료 매크로 문자(Standard Terminating Macro Characters)
-------------------------------------
&quot; ’ ( ) , ; ‘


표준 비-종료 매크로 문자(Standard Non-Terminating Macro Characters)
-----------------------------------------
#


표준 단일 예외 문자(Standard Single Escape Characters)
---------------------------------
\


표준 다수 예외 문자(Standard Multiple Escape Characters)
-----------------------------------
|


표준 공백 문자(Standard Whitespace Characters)
------------------------------
&lt;tab&gt; &lt;space&gt; &lt;page&gt; &lt;newline&gt; &lt;return&gt; &lt;linefeed&gt;
</code></pre>
<p><code>READ</code>가 구성문자(constituent character)로 시작한다면, 이는 심볼이나 숫자를 축적합니다. <code>READ</code>가 종료 매크로 문자(terminating macro character)나 공백 문자(whitespace character)를 만나면, 이는 모아진 구성문자를 우선 숫자로, 그 다음 symbol로 이해interpret하려 시도합니다. 수치화 해석이 가능하다면, <code>READ</code>는 숫자를 반환합니다. 그렇지 않으면, <code>READ</code>는 영문자를 standard case(보통은 대문자)로 바꾸어, 심볼로써 이름을 intern하여, 심볼을 반환합니다.</p>
<p>예외문자(Escape characters)는 특별한 역활을 수행합니다. 하나의 예외문자는 다음에 나오는 문자를 마치 constituent character처럼 다루도록 합니다. 보통 공백이나 종료매크로문자로 취급되는 문자는 심볼의 일부가 될 수 있습니다. READ가 escape character를 만나면, 숫자들로만 된것이 escape될지라도, constituents 결과를 숫자로 interpret 하려 하지 않을 것입니다</p>
<p><code>READ</code>시 매크로 문자(macro character)로 시작한다면, 문자는 다음 경우를 판별할 것입니다.</p>
<div class="table-wrapper"><table><thead><tr><th>문자</th><th>설명</th></tr></thead><tbody>
<tr><td>&quot;</td><td>문자열을 읽는다.</td></tr>
<tr><td>’</td><td>폼을 읽는다.</td></tr>
<tr><td>(</td><td>리스트를 읽는다.</td></tr>
<tr><td>;</td><td>새로운 라인을 만나기 전까지 모든 것을 무시한다.</td></tr>
<tr><td>#</td><td>다음 나오는 문자에 기반하여 무엇인지 결정한다.</td></tr>
</tbody></table>
</div>
<p>마지막으로, 몇몇 리스프 데이터는 읽을 수 없습니다. 예를들어, 해쉬테이블이 출력되어 보여지는 것은 <code>#&lt;HASH-TABLE&gt;</code>와 같이 보여집니다. <code>#&lt;</code> 문자로 시작하는 어떠한 것을 읽으려할때 READ는 에러를 낼 것입니다.</p>
<h2 id="print-writes-lisp-data-for-you-and-for-read"><a class="header" href="#print-writes-lisp-data-for-you-and-for-read">PRINT writes Lisp data for you and for READ</a></h2>
<p><code>print</code> 함수는 리스프 오브젝트를, READ가 이를 재구성해야만 하는, 문자열(sequence of characters)로 바꿉니다:</p>
<pre><code class="language-lisp">(print ’abc)
=  \newline ABC \space
;;=&gt; ABC

(print (list 1 2 3))
=  \newline (1 2 3) \space
;;=&gt; (1 2 3)

(print &quot;A String&quot;)
=  \newline &quot;A string&quot; \space
;;=&gt; &quot;A string&quot;

(print 387.9532)
=  \newline 387.9532 \space
;;=&gt; 387.9532

(print (make-hash-table))
=  \newline #&lt;HASH-TABLE&gt; \space
;;=&gt; #&lt;HASH-TABLE&gt;
</code></pre>
<p><code>PRINT</code>는 개행문자(<code>\newline</code>)로 시작하고 띄어쓰기(<code>\space</code>)으로 끝나는 결과물을 출력합니다. 개행과 띄어쓰기 모두 공백(whitespace)으로 취급되므로, (escape가 아닌)리스프 오브젝트가 출력된 표현의 일부가 될수 없기에, 이는 PRINT 결과물이 다른 결과물과는 다르다는 것을 보증합니다.</p>
<p><code>PRINT</code>의 다른 변종들은 다양한 쓰임세를 지녔습니다. <code>PRIN1</code>은 <code>PRINT</code>처럼 행동하지만, whitespace로 감싸지 않습니다. 예를들어 연이은 조각들로부터 이름을 만들고자 할때, 이는 유용할 것입니다. PRINC는 PRIN1처럼 행동하지만, 보여는것 보단 READ를 위한 결과물을 생성합니다; 예를들어, PRINC는 문자열을 둘러싸는 쌍따옴표(quotes)를 생략하며, escape character를 출력하지 않습니다.</p>
<pre><code class="language-lisp">(print ’a\ bc)
;;&gt;&gt;  \newline  |A BC| \space
;;=&gt; |A BC|

(prin1 ’a\ bc)
;;&gt;&gt; |A BC|
;;=&gt; |A BC|

(princ ’|A BC|)
;;&gt;&gt; \newline  A BC \space
;;=&gt; |A BC|
</code></pre>
<h2 id="open과-close는-파일을-다룰-수-있게-한다"><a class="header" href="#open과-close는-파일을-다룰-수-있게-한다">OPEN과 CLOSE는 파일을 다룰 수 있게 한다.</a></h2>
<p>보통, <code>READ</code>는 키보드를 읽고 <code>PRINT</code>는 화면에 출력합니다. 이러한 함수 모두 옵셔널(optional) 인자를 취합니다; 인자는 <code>READ</code>를 위한 입력 스트림과 <code>PRINT</code>를 위한 출력 스트림을 지정합니다. 스트림(stream)은 무엇일까요? 스트림은 데이터의 근원(source)이자 밑바닥(sink)이며, 보통 (그치만 절대적이지는 않은) 문자(characters)입니다. 이제부터, 저희는 tex file이 어떻게 문자 stream의 source나 sink가 될 수 있는지를 살펴볼 것입니다. 19장 [p 183]에서 저희는 몇몇 다른 가능성들을 살펴볼 것입니다.</p>
<p>여러분은, 파일 이름을 인자로 취하고 스트림의 방향(입력과 출력)을 결정하는 키워드 인자를 취하는, <code>OPEN</code> 함수를 이용하여 스트림을 파일로 붙일 수 있습니다. 스트림에 관한 작업을 종료하고 관련된 파일을 닫기 위해선, <code>CLOSE</code> 함수를 사용합니다.</p>
<pre><code class="language-lisp">(setq out-stream (open &quot;my-temp-file&quot; :direction :output))
;;=&gt; #&lt;OUTPUT-STREAM &quot;my-temp-file&quot;&gt;

(print 'abc out-stream)
;;=&gt; ABC

(close out-stream)
;;=&gt; T

(setq in-stream (open &quot;my-temp-file&quot; :direction :input))
;;=&gt; #&lt;INPUT-STREAM &quot;my-temp-file&quot;&gt;

(read in-stream)
;;=&gt; ABC

(close in-stream)
;;=&gt; T
</code></pre>
<p>이 예제에서, 저희는 <code>my-temp-file</code>에 대한 출력 스트림을 만들고, 심볼 <code>ABC</code>를 그 스트림에 출력하였습니다. 인자는 평상시처럼 반환하지만 출력을 하지 않는 다는 것을 주목하시기 바랍니다 - 대신, 출력된 결과는 파일로 갑니다.</p>
<p>다음으로, 출력 스트림을 닫고 동일한 파일에 입력 스트림을 열었습니다. 그런 다음 저희가 파일에 출력한 심볼을 읽어온 다음, 입력 스트림을 닫음으로써 끝을 맺습니다.</p>
<h2 id="variations-on-a-print-theme"><a class="header" href="#variations-on-a-print-theme">Variations on a PRINT theme</a></h2>
<p>리스프는 또한, 이러한 옵션을 제어하는 키워드 인자를 이용하여, 여러분에게 출력에 대해 더욱 세부적인 것에 관한 제어권을 주는 <code>WRITE</code> 함수를 제공합니다:</p>
<div class="table-wrapper"><table><thead><tr><th>Keyword Argument</th><th>Default Value</th><th>Action</th></tr></thead><tbody>
<tr><td>:stream</td><td><code>t</code></td><td>set output stream</td></tr>
<tr><td>:escape</td><td><code>*print-escape*</code></td><td>include escape characters</td></tr>
<tr><td>:radix</td><td><code>*print-radix*</code></td><td>include radix (base) prefix</td></tr>
<tr><td>:base</td><td><code>*print-base*</code></td><td>set number base (rationals)</td></tr>
<tr><td>:circle</td><td><code>*print-circle*</code></td><td>print circular structures</td></tr>
<tr><td>:pretty</td><td><code>*print-pretty*</code></td><td>add whitespace for readability</td></tr>
<tr><td>:level</td><td><code>*print-level*</code></td><td>limit nesting depth</td></tr>
<tr><td>:length</td><td><code>*print-length*</code></td><td>limit items per nesting level</td></tr>
<tr><td>:case</td><td><code>*print-case*</code></td><td>:upper, :lower, or :mixed</td></tr>
<tr><td>:gensym</td><td><code>*print-gensym*</code></td><td>prefix uninterned symbols</td></tr>
<tr><td>:array</td><td><code>*print-array*</code></td><td>print arrays readably</td></tr>
<tr><td>:readably</td><td><code>*print-readably*</code></td><td>force printing to be readable</td></tr>
<tr><td>:right-margin</td><td><code>*print-right-margin*</code></td><td>controls pretty-printing</td></tr>
<tr><td>:miser-width</td><td><code>*print-miser-width*</code></td><td>&quot;</td></tr>
<tr><td>:lines</td><td><code>*print-lines*</code></td><td>&quot;</td></tr>
<tr><td>:pprint-dispatch</td><td><code>*print-pprint-dispatch*</code></td><td>&quot;</td></tr>
</tbody></table>
</div>
<p>우연하게도, 위에 키워드 인자의 기본값으로 나온 변수들은 또한 <code>PRINT</code>의 연산을 제어합니다. 여러분은, <code>PRIN1</code>을 감싸는 <code>LET</code> 폼에서 이러한 변수들을 바인딩 함으로써, non-default 키워드 인자로 <code>WRITE</code>의 효과를 얻을 수 있습니다:</p>
<pre><code class="language-lisp">(write foo
       :pretty t
       :right-margin 60
       :case :downcase)


(let ((*print-pretty* t)
      (*print-right-margin* 60)
      (*print-case* :downcase))
  (prin1 foo))
</code></pre>
<p><code>PRINT</code>가 추가하는 앞에 newline이 있고 뒤에 빈칸(blank)이 오는걸 원치 않기에, <code>print</code>가 아닌 <code>prin1</code>를 사용하였습니다.</p>
<p>여러분의 프로그램이 <code>*PRINT-...*</code> 변수를 바꾸지만, 프로그램의 어느 지점에서 기본 값(default value)을 쓰고자 한다면, <code>with-standard-io-syntax</code> 폼으로 프로그램의 일부를 감쌀 수 있습니다:</p>
<pre><code class="language-lisp">;;프로그램의 printer control을 정의한다.
(setq *print-circle* t)
(setq *print-array* nil)
(setq *print-escape* nil)
...

;;위에서 설정한 걸 출력한다.
(print ...)
...

;;default printer control 설정으로 되돌린다.
(with-standard-io-syntax
   ...
   ; standard setting으로 출력한다음,
   ; 위에서 설정한 이러한 것들을 덮어쓴다.
   (print ...)
   ...)
;; WITH-STANDARD-IO-SYNTAX form 밖에선,
;; 예제 상단에 있는 SETQ 폼에 의해
;; 구축establish된 print 설정을 또 다시 해야합니다.
</code></pre>
<h2 id="짚고-넘어가기-11"><a class="header" href="#짚고-넘어가기-11">짚고 넘어가기</a></h2>
<ul>
<li><code>print</code></li>
<li><code>prin1</code></li>
<li><code>princ</code></li>
<li><code>write</code></li>
<li><code>with-standard-io-syntax</code></li>
<li><code>open</code></li>
<li><code>close</code></li>
<li><code>*print-circle*</code></li>
<li><code>*print-array*</code></li>
<li><code>*print-escape*</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="레슨-12-필수---리더-매크로essential-reader-macros"><a class="header" href="#레슨-12-필수---리더-매크로essential-reader-macros">레슨 12. 필수 - 리더 매크로(Essential Reader Macros)</a></h1>
<ul>
<li><a href="https://dept-info.labri.fr/~strandh/Teaching/MTP/Common/David-Lamkins/chapter03-12.html">원문</a></li>
</ul>
<h2 id="리더reader는-문자를-데이터로-만든다"><a class="header" href="#리더reader는-문자를-데이터로-만든다">리더(reader)는 문자를 데이터로 만든다</a></h2>
<p>레슨 11에서 리스프 리더가 constituent characters를 심볼과 숫자로 모으gather고 macro characters가 lists, strings, quoted forms, comments를 다루기 위해 reader를 제어하는 것을 보았습니다. 이 모든 경우에, reader는 문자(characters)를 데이터로 바꿉니다 (좀 더 분명히 하자면, comment는 &quot;데이터가 아닙니다&quot;.)</p>
<h2 id="standard-reader-macros-handle-built-in-data-types"><a class="header" href="#standard-reader-macros-handle-built-in-data-types">Standard reader macros handle built-in data types</a></h2>
<p>지금까지, 우리는 리스프의 기본 문법만을 살펴보았습니다. 이는 reader에 의해 구현되며, readtable에 의해 제어됩니다. reader는 readtable에 저장되어있는 정보를 따라 characters를 처리합니다.</p>
<h2 id="user-programs-can-define-reader-macros"><a class="header" href="#user-programs-can-define-reader-macros">User programs can define reader macros</a></h2>
<p>리스프는 리드테이블(readtable)을 <code>*readtable*</code>변수를 통해 나타내며, 리스프는 리드테이블에 있는 항목을 다룰 수 있는 함수를 제공합니다. 여러분은 이를 이용하여 리스프 리더의 행동을 바꿀 수 있습니다. 다음 예제에서, 우리는 문법을 바꿀 것이며 [와 ]를 이용하여 quoted(즉, 평가되지 않는) 리스트를 작성할 수 있을 것입니다.</p>
<pre><code class="language-lisp">;;이는 틀렸습니다:
(1 2 3 4 5 6)
;;&gt;| Error: 1 is not a function

;; 대신에 이렇게 해야 합니다:
'(1 2 3 4 5 6)
;;=&gt; (1 2 3 4 5 6)

;;새로운 문법을 정의하여
;; '(1 2 3 4 5 6)
;;대신에
;; [1 2 3 4 5 6]
;;이처럼 작성할 수 있게 합시다.
(defun open-bracket-macro-character (stream char)
  `',(read-delimited-list #\] stream t))
;;=&gt; OPEN-BRACKET-MACRO-CHARACTER

(set-macro-character #\[ #'open-bracket-macro-character)
;;=&gt; T

(set-macro-character #\] (get-macro-character #\)))
;;=&gt; T

;;이제 테스트 해봅시다:
[1 2 3 4 5 6]
;;=&gt; (1 2 3 4 5 6)
</code></pre>
<p>처음 저희는 <code>(1 2 3 4 5 6)</code>을 평가하려 했습니다: <code>1</code>은 함수가 아니기에, 이는 옳지않습니다.
저희가 실제로 해야하는 것은 리스트를 <code>quote</code> 하는 것입니다. 그러나 이러한 작업을 매번 해야한다면, 더욱 편리한 문법을 원하게 될 것입니다. 특히, <code>'(...)</code>과 같은 행동을 하는 <code>[...]</code>이 있었으며 좋겠습니다.</p>
<p>이를 수행하기 위해, 이의 인자를 평가하지 않는 specialized list reader macro 함수를 정의해야 합니다. 저희는 reader가 [ 문자를 만나면 함수가 호출되도록 할 것입니다; 함수는 ] 문자를 만나면 리스트를 반환할 것입니다. 모든 reader macro function은 두개의 인자에 의해 호출됩니다: input stream과 macro를 작동시키는 문자.</p>
<p>리스프가 한정된delimited 리스트를 읽도록 설계된 함수를 지녔기에, 저희 reader 매크로는 매우 단순합니다. READ-DELIMITED-LIST는 하나의 인자를 기다립니다 - 읽고있는 리스트를 종료시키는 문자. 다른 두개의 인자는 optional입니다 - input stream과 (reader macro 함수에서 사용될땐 보통 T로 설정되는)flag. READ-DELIMITED-LIST는 terminating character를 만나기 전까지 input stream에서 objects를 읽은다음, 모든 objects를 list로 반환합니다. 자체적으로, 이는 평가를 막는것suppressing을 제외한 저희가 필요한 모든것을 수행합니다.</p>
<p>레슨 3에서 봤던것 처럼, <code>QUOTE</code> (혹은  <code>'</code>)는 평가를 막습니다. 그러나 저희는 <code>'(READ-DELIMITED-LIST ...)</code>를 사용할 수 없습니다; 이는, 저희가 <code>quote</code> 하고자 하는 폼을 얻기 위해 저희가 평가하고자 하는, 폼의 평가를 막습니다... 대신, <code>quote</code>된 폼에 대해 선택적인 평가를 요구하는 <code>`</code>(레슨 8 참조)를 이용하였습니다.</p>
<p>저희 <code>OPEN-BRACKET-MACRO-CHARACTER</code>의 정의는 폼을 평가하고 <code>quote</code>된 결과를 반환하기 위해
<code>`',form</code>
을 이용하였습니다.</p>
<ul>
<li>리스프는 프로그래머를 위해 6개의 문자를 예약하였습니다: <code>[ ] { } ! ?</code></li>
</ul>
<p>여러분은 이중 일부나 전체를 리스프의 중재없이 매크로 문자를 정의할 수 있습니다. 그러나, 다른 프로그래머와 코드를 공유하게 된다면, 논쟁이 발생할 수 있다는 점을 주의해야 합니다.</p>
<h2 id="짚고-넘어가기-12"><a class="header" href="#짚고-넘어가기-12">짚고 넘어가기</a></h2>
<ul>
<li><code>*readtable*</code></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
