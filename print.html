<!DOCTYPE HTML>
<html lang="kr" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Successful Lisp - 한국어판</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="Successful Lisp">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Index.html">들어가며</a></li><li class="chapter-item expanded affix "><li class="part-title">03. 12개의 레슨으로 배우는 필수 리스프</li><li class="chapter-item expanded "><a href="ch03/ch03.html">03. 12개의 레슨으로 배우는 필수 리스프</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03/lesson_01.html">레슨 01. 필수 - 신택스</a></li><li class="chapter-item expanded "><a href="ch03/lesson_02.html">레슨 02. 필수 - 평가</a></li><li class="chapter-item expanded "><a href="ch03/lesson_03.html">레슨 03. 스페셜 폼과 매크로에 대한 예제</a></li><li class="chapter-item expanded "><a href="ch03/lesson_04.html">레슨 04. 조립과 분해</a></li><li class="chapter-item expanded "><a href="ch03/lesson_05.html">레슨 05. 네이밍과 아이덴티티</a></li><li class="chapter-item expanded "><a href="ch03/lesson_06.html">레슨 06. 바인딩 vs 할당</a></li><li class="chapter-item expanded "><a href="ch03/lesson_07.html">레슨 07. 필수 - 함수 정의</a></li><li class="chapter-item expanded "><a href="ch03/lesson_08.html">레슨 08. 필수 - 매크로 정의</a></li><li class="chapter-item expanded "><a href="ch03/lesson_09.html">레슨 09. 필수 - 다중 값</a></li><li class="chapter-item expanded "><a href="ch03/lesson_10.html">레슨 10. 프리뷰 - 다른 데이터 타입</a></li><li class="chapter-item expanded "><a href="ch03/lesson_11.html">레슨 11. 필수 - 입력과 출력</a></li><li class="chapter-item expanded "><a href="ch03/lesson_12.html">레슨 12. 필수 - 리더 매크로</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Successful Lisp - 한국어판</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/lispkorea/successful-lisp-kr" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="들어가며"><a class="header" href="#들어가며">들어가며</a></h1>
<p>successful Lisp의 3장 - 12개의 레슨으로 배우는 필수 리스프 번역본입니다.</p>
<h2 id="ref"><a class="header" href="#ref">Ref</a></h2>
<ul>
<li><a href="https://dept-info.labri.fr/~strandh/Teaching/MTP/Common/David-Lamkins/contents.html">https://dept-info.labri.fr/~strandh/Teaching/MTP/Common/David-Lamkins/contents.html</a>
<ul>
<li><a href="https://github.com/TieDyedDevil">https://github.com/TieDyedDevil</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="03-12개의-레슨으로-배우는-필수-리스프"><a class="header" href="#03-12개의-레슨으로-배우는-필수-리스프">03. 12개의 레슨으로 배우는 필수 리스프</a></h1>
<p>이번 장은 여러분에게 리스프를 시작하기에 앞서 알아야 할 모든것을 가르칠 것입니다.</p>
<p>언어의 코어 기능들을 모두 다룰 것입니다. 여러분이 이 코어를 리스프 자체라 생각하고, 그렇지 않은 것은 하나의 거대한 표준 라이브러리라 생각하셨으면 합니다. 책을 읽은 후 이를 배경으로, <code>Common Lisp : The Language, 2nd Edition</code>과 같은 메뉴얼을 참조하면, 더욱 편하게 리스프의 남은 부분들을 배울 수 있을 것입니다.</p>
<p>여러분은 이번 장을 한번에 쭉 읽어야 합니다. 이따금 다음 단락이나 다음 장에대해 언급하겠지만, 이번장을 이해하기 위해서 반드시 그러한 참고들을 따를 필요는 없습니다. 이번 장을 끝낼 무렵, 여러분은 이미 리스프 시스템의 키보드 앞에 앉아 4장을 진행하고 있을 것 입니다.</p>
<h2 id="짚고-넘어가기"><a class="header" href="#짚고-넘어가기">짚고 넘어가기</a></h2>
<ul>
<li><a href="https://www.cs.cmu.edu/Groups/AI/html/cltl/cltl2.html">Common Lisp : The Language, 2nd Edition</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="레슨-01-필수---신택스essential-syntax"><a class="header" href="#레슨-01-필수---신택스essential-syntax">레슨 01. 필수 - 신택스(Essential Syntax)</a></h1>
<ul>
<li><a href="https://dept-info.labri.fr/~strandh/Teaching/MTP/Common/David-Lamkins/chapter03-01.html">원문</a></li>
</ul>
<h2 id="리스트는-괄호로-감싸져있다"><a class="header" href="#리스트는-괄호로-감싸져있다">리스트는 괄호로 감싸져있다.</a></h2>
<p>리스프에 대해 우선적으로 알아할 것입니다: 괄호로 둘러싸인 모든것은 <code>리스트(list)</code>이다.</p>
<p>여기 예가 있습니다:</p>
<pre><code class="language-lisp">(1 2 3 4 5)

(a b c)

(cat 77 dog 89)
</code></pre>
<p>앞서 말씀드린대로, 괄호로 둘러싸인 것은 <code>리스트</code>입니다.</p>
<p>이와 같은 말을 들으면, 아마 다음과 같은 의문이 생길 것입니다:</p>
<ol>
<li>괄호로 아무것도 없는것을 둘러싼다면?</li>
<li>괄호로 다른 리스트를 둘러싼다면?</li>
</ol>
<p>두 경우 모두 대답은 같습니다. 여전히 <code>리스트</code>입니다.</p>
<p>따라서 다음 나오는 것들 또한 <code>리스트</code>입니다:</p>
<pre><code class="language-lisp">()

(())

((()))

((a b c))

((1 2) 3 4)

(mouse (monitor 512 342) (keyboard US))

(defun factorial (x) (if (eql x 0) 1 (* x (factorial (- x 1)))))
</code></pre>
<p>리스트가 아닌 유일한 경우는 다음 4개의 예제에 나온 것처럼, 좌/우측 괄호가 짝을 이루지 못하는 경우입니다:</p>
<pre><code class="language-lisp">(a b c(                   ; (: 2개 // ): 0개

((25 g) 34                ; (: 2개 // ): 1개

((())                     ; (: 3개 // ): 2개

(()))                     ; (: 2개 // ): 3개
</code></pre>
<p>크게 신경쓸 부분은 아닙니다: 리스프는 괄호가 일치하지 않으면 않다고 여러분에게 알려 줄 것입니다.
또, 리스프 프로그램을 작성하기 위해 사용하는 편집기 대부분은 자동적으로 일치하는 괄호를 찾는 방법을 제공해 줄 것입니다. 27장에서 편집기에 대해 살펴볼 수 있습니다 [p 227].</p>
<p>리스프에서 <code>리스트</code>는 여러가지가 될 수 있습니다. 가장 일반적인 경우, <code>리스트</code>는 프로그램이나 데이터가 될 수 있습니다. 그리고 <code>리스트</code>가 스스로 다른 리스트를 만들 수 있기에, 여러분은 복잡한 데이터의 조합과 여러 단계의 리스트 구조로 된 프로그램을 가질 수 있습니다. 이를 잘 이해하는 자에게는 리스프는 엄청난 유연성을 부여해 줄 것이며, 그렇지 않은 자에게는 많은 혼란을 줄 것입니다. 이번장을 계속해서 나아가면서 이러한 혼란을 없애도록 노력해 봅시다.</p>
<h2 id="아톰atom은-공백이나-괄호로-분리된-것입니다"><a class="header" href="#아톰atom은-공백이나-괄호로-분리된-것입니다">아톰(Atom)은 공백이나 괄호로 분리된 것입니다.</a></h2>
<p>이제 여러분은 리스트를 구분할 수 있으며, 괄호 사이에 나타나지만 (리스트가 아닌)단어나 숫자인 것들에 대한 것들을 뭐라고 부르는지 알고 싶을 것입니다. 이러한 것들을 <code>아톰(atom)</code>이라 부릅니다.</p>
<p>그러므로, 다음 단어와 숫자들은 모두 <code>아톰</code>입니다:</p>
<pre><code class="language-lisp">1

25

342

mouse

factorial

x
</code></pre>
<p>리스프에서는 거의 모든 문자를 이용하여 아톰을 구성할 수 있습니다. 이제부터 문자, 숫자, 구두점 문자들이 있는데 이들 앞뒤에 공백(줄의 시작 또는 끝 포함) 또는 괄호가 있으면 이를 모두 <code>아톰</code>이라고 부르겠습니다. 다음 나오는 것들은 모두 <code>아톰</code>입니다:</p>
<pre><code class="language-lisp">-

*

@comport

funny%stuff

9^

case-2
</code></pre>
<p>만일 다른 프로그래밍에 대한 경험이 있다면, 한가지 주의해야 할 점은 보통 다른 언어에서 연산자로 예약된 문자들이 리스프에서 아톰으로써 쓰였다면 별다른 의미를 갖지 않는다는 것입니다. 예를들어, <code>case-2</code>는 수학적(arithmetic) 표현식 뺄샘이 들어간게 아니라 여기서는 그져 <code>아톰</code> 그 자체입니다.</p>
<p>공백이나 괄호로 무엇이 <code>아톰</code>인지 구분할 수 있으므로, 아톰과 괄호 혹은 괄호들 사이에 있는 공백을 없앨 수 있습니다. 그러므로, 다음 두 예제는 동일합니다:</p>
<pre><code class="language-lisp">(defun factorial (x) (if (eql x 0) 1 (* x (factorial (- x 1)))))

(defun factorial(x)(if(eql x 0)1(* x(factorial(- x 1)))))
</code></pre>
<p>사실, 여러분은 절대로 두번째에 나타난것처럼 리스트를 작성해서는 안됩니다. 여러분은 가독성을 향상시키기 위해 리스트를 여러 라인으로 분리시키며 각 라인을 적절히 들여써야 합니다. 이 리스트는 사실 작은 프로그램이며, 다음과 같이 들여쓰면 리스퍼 프로그래머가 읽기 수월해 집니다:</p>
<pre><code class="language-lisp">(defun factorial (x)
  (if (eql x 0)
      1
      (* x (factorial (- x 1)))))
</code></pre>
<p>지금, 여러분은 이것이 무얼 의미하는지, 이러한 종류의 들여쓰기(indentation)가 무엇인지 대해 걱정할 필요가 없습니다. 이번장을 통해, 여러분은 들여쓰기가 들어간 많은 예제를 접하게 될 것입니다.</p>
<p>계속해서 보여드리는 예제와 함께, 가독성을 향상시키는 들여쓰는 방법에 대해 알려드릴 것입니다. 28장 [p 230]에서 적절한 들여쓰는 법을 포함하여, 리스프의 코딩 스타일에 대해 다룰 것입니다.</p>
<h2 id="짚고-넘어가기-1"><a class="header" href="#짚고-넘어가기-1">짚고 넘어가기</a></h2>
<ul>
<li>리스트(list)</li>
<li>아톰(atom)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="레슨-02-필수---평가essential-evaluation"><a class="header" href="#레슨-02-필수---평가essential-evaluation">레슨 02. 필수 - 평가(Essential Evaluation)</a></h1>
<ul>
<li><a href="https://dept-info.labri.fr/~strandh/Teaching/MTP/Common/David-Lamkins/chapter03-02.html">원문</a></li>
</ul>
<h2 id="폼form은-평가될-수-있습니다"><a class="header" href="#폼form은-평가될-수-있습니다">폼(form)은 평가될 수 있습니다.</a></h2>
<p><code>폼(form)</code>은 <code>아톰(atom)</code> 혹은 <code>리스트(list)</code>가 될 수 있습니다. 중요한 것은 <code>폼</code>이 <code>평가(evaluation)</code>된다는 것입니다. 평가라는 것은 상당한 기술적 의미를 지니고 있으며, 이번 섹션에서 서서히 그 모습을 드러나게 될 것입니다.</p>
<p><code>폼</code>이 아톰이라면 평가는 단순합니다. 리스프는 아톰을 마치 이름처럼 다루고, 값이 존재한다면 이름에 저장된 값을 얻습니다. 여러분은 아마도 왜 제가 아톰은 변수라고 직접적으로 말하지 않는지 의아할 것입니다. 명확하게 정의하지 않은 이유는 아톰은 변수이거나 상수의 값을 가질 수 있기 때문입니다. 그리고 아톰의 값은 경우에 따라 상수가 될 수 도 있습니다.</p>
<p>숫자는 <code>아톰</code>입니다(이 값은 상수입니다). 리스프는 숫자에 값을 저장 할 수 없습니다: 숫자는 자체적으로 평가됩니다.</p>
<p>정의가 완전히 내려지지 않은 새로운 용어를 소개합니다. 이제, 심볼을 값을 가질 수 있는 <code>아톰</code>이라고 여기기 바랍니다. 레슨 5[p 53]에서 심볼에 대해 더욱 자세히 살펴볼 것입니다.</p>
<p><code>defconstant</code>로 정의된 심볼은 상수 값을 지닙니다. 리스프는 변수처럼 아톰에 값을 저장한 다음, 값을 바꿀 수 없다라는 메모를 추가합니다.</p>
<p>패키지에 있는 <code>키워드(keyword) 심볼</code>은 스스로 평가됩니다. 패키지에 관한 것은 31장[p 247]에서 자세히 살펴볼 것입니다. 지금, 여러분이 알아야 할것은 (패키지 프리픽스라 불리는) <code>:</code> 문자로 시작하는 심볼은 <code>키워드 심볼</code>이라는 것입니다. <code>키워드 심볼</code>은 그 자신을 값으로 갖습니다.</p>
<p>다양한 방식으로 심볼에서 값을 얻을 수 있습니다. 리스프는 실제로 심볼에 다양한 값을 저장합니다. 하나는 변수로서의 심볼의 값. 그리고 다른 하나는 함수로서 심볼입니다. 또 다른 것들은 해당 심볼에 대한 문서를 얻거나, 출력값으로 활용하거나, 연관리스트(associated list)처럼 속성값으로 쓰이기도 합니다. 이러한 것들에 대해 레슨 5 [p 53], 레슨 6 [p 56], 레슨 7 [p 59]에서 더욱 자세히 살펴볼 것입니다.</p>
<p>폼이 리스트라면, 첫번째 요소는 심볼이거나 람다(lambda)표현식이라 불리는 특별한 폼일 것입니다. (람다 표현식에 대한것은 잠시 뒤로 미루겠습니다.)
심볼은 함수의 이름을 짓습니다. 리스프에서 심볼 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>는 일반적인 산술 연산자입니다: 덧셈, 빨셈, 곱셈, 나누기. 각 심볼은 산술 연산을 수행하는 함수와 연관되어있습니다.</p>
<p>따라서 리스프가 폼 <code>(+ 2 3)</code>을 평가하면, 이는 덧셈 함수<code>+</code>에 인자 <code>2</code>와 <code>3</code>을 적용시킬 것이며, 예상되듯이 결과 <code>5</code>를 반환할 것입니다. 함수로서 심볼 <code>+</code>가 인자들 앞에 있습니다. 이는 <code>전위 표기법(prefix notation)</code>입니다. 리스프가 리스트를 폼으로 평가하기 위해 무얼할 것인지 이해하기 위해선, 리스트의 첫번째 요소를 살펴보시기 바랍니다.</p>
<h2 id="함수는-인자를-받을-수-있습니다"><a class="header" href="#함수는-인자를-받을-수-있습니다">함수는 인자를 받을 수 있습니다.</a></h2>
<p>주어진 리스트를 평가할때 리스프는 폼을 함수 호출로써 다룹니다. 지금부터 우리는 수 많은 리스프의 평가를 보게 될 것이며, 리스프의 입력과 이의 반응을 구분하기 위해 다음과 같이 시각적 표시를 할 것입니다:</p>
<pre><code class="language-lisp">(어떠한 리스프 입력)
;;=&gt; 리스프 평가의 결과

;;&gt;&gt; 리스프 출력
;;&lt;&lt; 리스프에 입력
;;&gt;| 리스프의 에러 메시지
</code></pre>
<p>예:</p>
<pre><code class="language-lisp">(+ 4 9)
;;=&gt; 13

(- 5 7)
;;=&gt; -2

(* 3 9)
;;=&gt; 27

(/ 15.0 2)
;;=&gt; 7.5
</code></pre>
<p>위 경우에서 보듯이, 평가된 폼은 리스트입니다. 각각의 첫번째 요소는 심볼이자 함수의 이름입니다. 남아있는 요소는 해당 함수의 인자입니다. 여기서, 인자는 모두 숫자이며, 숫자는 스스로 평가된다는 것을 알 수 있습니다.</p>
<p>여기 몇몇 예제가 더 있습니다:</p>
<pre><code class="language-lisp">(atom 123)
;;=&gt; T

(numberp 123)
;;=&gt; T

(atom :foo)
;;=&gt; T

(numberp :foo)
;;=&gt; NIL
</code></pre>
<p><code>atom</code>과 <code>numberp</code>는 술어(predicate)입니다. 술어는 참 혹은 거짓을 반환합니다. 리스프에서 <code>NIL</code>은 거짓을 나타냅니다. <code>NIL</code>이 아닌 것은 모두 참입니다. 딱히 의미있는 값이 아니면 술어는 관습적으로 참을 의미하는 <code>T</code>를 반환하게 되어 있습니다. <code>atom</code>은 인자가 리스프의 아톰이라면 <code>T</code>를 반환합니다. <code>numberp</code>는 인자가 숫자이면 <code>T</code>를 반환합니다.</p>
<p>위의 폼들을 평가하기 위해, 리스프는 우선 (좌측에서 우측으로) 인자를 평가하고, 그런 다음 첫번째 요소를 평가하여 함수를 얻은 후, 앞선 인자들을 함수에 적용합니다. 몇몇 예외가 있지만, 그것들은 이번 레슨의 끝부분에서 배울 것입니다.</p>
<p>리스프는 리스트 폼을 평가하기 위해 다음과 같은 작업을 수행합니다:</p>
<ol>
<li>나머지 요소들을 좌측에서부터 우측으로 인자들을 평가한다.</li>
<li>첫번째 요소에서 함수를 얻는다.</li>
<li>함수에 인자들을 적용한다.</li>
</ol>
<p><code>아톰</code> 또한 <code>리스프의 폼</code>이라는 것을 명심하시기 바랍니다. 주어진 아톰이 평가되면, 리스프는 아톰이 지닌 값을 반환합니다:</p>
<pre><code class="language-lisp">17.95
;;=&gt; 17.95

:A-KEYWORD
;;=&gt; :A-KEYWORD

*FEATURES*
;;=&gt; (:ANSI-CL :CLOS :COMMON-LISP)

&quot;Hello, world!&quot;
;;=&gt; &quot;Hello, world!&quot;

WHAT-IS-THIS?
;;&gt;| Error: Unbound variable
</code></pre>
<p>숫자와 키워드는 스스로 평가됩니다. 문자열도 그러합니다. <code>*FEATURES*</code>는 리스프에 의해 미리 정의된 변수입니다. 여러분의 시스템은 아마도 다른 값을 반환할 것입니다.</p>
<p>심볼 <code>WHAT-IS-THIS?</code>는 리스프에 의해 미리 정의되지 않아 값을 지니지 않으며, 이에 값을 얻을 수 없습니다. 시스템은 값 대신에 에러메시지로 응답할 것입니다. 에러 메시지 앞에 <code>;;&gt;|</code>를 붙여 표시하였습니다. 시스템에 따라 다른 에러 메시지가 출력될 수 있습니다.</p>
<h2 id="함수는-다수의-값을-반환-할-수-있다"><a class="header" href="#함수는-다수의-값을-반환-할-수-있다">함수는 다수의 값을 반환 할 수 있다.</a></h2>
<p>우리는 종종 다수의 값을 반환하는 함수를 갖길 원합니다. 예를들어, 데이터베이스 전체를 살펴보는 함수는 요구하는 값과 완료상태코드를 동시에 반환해야 합니다. 이를 행할 방법으로는 해당 결과값을 저장할 위치 자체를 함수에 전달하는 것입니다; 가능은 하지만, 리스프 프로그램에서는 매우 드믄 일입니다.</p>
<p>또 다른 접근법은 결과와 상태코드를 하나로 묶어 하나의 반환 값으로 만드는 것입니다.
리스프는 구조체[p 72]를 포함하여 여러분에게 이를 수행할 다양한 방식을 제공합니다. 다만, 이와같이 하나로 묶는 방식은 잘못하면 가비지(29장 [p 238] 참조)가 생성되어 프로그램 작동 속도가 느려지게 만들 수 있기에 숙련된 리스프 프로그래머는 이와 같은 작업을 피합니다.</p>
<p>함수에서 다수의 값을 반환하는 올바른 법은 <code>values</code> 폼을 이용하는 것입니다. 잠시 후에 함수 컨텍스트안에서의 VALUES의 사용법을 [p 63]에서 살펴보도록 하겠습니다. 지금은, 리스프가 <code>values</code> 폼을 평가할때 무슨 일이 벌어지는지 살펴봅시다:</p>
<pre><code class="language-lisp">(values 1 2 3 :hi &quot;Hello&quot;)
;;=&gt; 1
;;=&gt; 2
;;=&gt; 3
;;=&gt; :HI
;;=&gt; &quot;Hello&quot;
</code></pre>
<p>리스프가 <code>values</code> 폼으로 각 인자에 대한 값을 반환하는 것을 확인할 수 있습니다.</p>
<h2 id="함수에서-인자를-수정하지-않는다"><a class="header" href="#함수에서-인자를-수정하지-않는다">함수에서 인자를 수정하지 않는다.</a></h2>
<p>앞서, 결과값을 저장할 위치 자체를 인자로 함수에 넘길 수 있으며, 함수가 그 위치의 값을 바꿀 수도 있다고 말한 바가 있습니다. 다른 언어들은 이를 일반적인 레파토리로 말할지라도, 리스프 프로그램에서 매우 드문 일입니다.</p>
<p>저장할 위치에 키워드가 아닌 심볼이나 구조체 같은 것을 넣을 수 는 있습니다. 심볼을 넣을 경우, 함수는 심볼에 새로운 값을 넣는 코드를 수행해야만 합니다. 구조체를 넣을 경우 구조체의 각 값을 올바르게 변경하는 코드를 수행해야만 합니다. 이러한 작업 자체도 복잡하고 이렇게 작성된 프로그램을 이해하는 것도 어렵습니다. 따라서 리스프 프로그래머들은 일반적으로 인자를 수정하지 않고, 인자는 인자, 결과는 결과로 구분된 함수를 작성합니다.</p>
<h2 id="인자는-보통은-함수가-적용-전에-평가된다"><a class="header" href="#인자는-보통은-함수가-적용-전에-평가된다">인자는 (보통은) 함수가 적용 전에 평가된다.</a></h2>
<p>리스프가 함수를 평가하면, 앞서 봤던것처럼[p 42], 항상 모든 인자를 우선적으로 평가합니다. 불행히도, 모든 규칙에는 예외가 있으며, (곧 보게될 것처럼)이 규칙도 예외는 아닙니다... 문제는 리스프가 함수의 인자를 평가하지 않을 수 있다라는 점이 아니라, 리스트 폼은 함수 호출이 아닐 수 도 있다라는 점입니다.</p>
<h2 id="인자들은-좌측에서-우측으로-순서대로-평가된다"><a class="header" href="#인자들은-좌측에서-우측으로-순서대로-평가된다">인자들은 좌측에서 우측으로 순서대로 평가된다</a></h2>
<p>리스트 폼이 함수를 호출하면, 이의 인자는 항상 좌측에서 우측으로 순서대로 평가됩니다.</p>
<h2 id="스페셜-폼과-메크로는-인자의-평가하는-방법을-바꿀-수-있다"><a class="header" href="#스페셜-폼과-메크로는-인자의-평가하는-방법을-바꿀-수-있다">스페셜 폼과 메크로는 인자의 평가하는 방법을 바꿀 수 있다.</a></h2>
<p>리스트 폼이 함수 호출이 아닐 수 도 있다 라고 했는데, 그럼 무엇이 될 수 있을까요?
2가지 경우가 있지만, 결과는 같습니다: 몇몇 인자는 평가되며 몇몇은 평가가 안됩니다. 폼이나 폼이 아니냐에 달려있습니다. 이 예외에 대해서만 알면 됩니다. 다행히도, 대부분의 리스프 시스템은 한두번의 키 입력으로 이에 대한 온라인 문서를 여러분에게 보여줄 것입니다.</p>
<p>모든 인자가 평가되지 않는 폼은 두가지가 있습니다: 스페셜 폼과 매크로. 리스프는 몇몇 스페셜 폼을 미리 정의해 두었습니다. 언어 자체의 주요 기능이기에 여러분만의 스페셜 폼을 추가할 수는 없습니다. 또 리스프는 몇몇 매크로를 미리 정의해두었습니다. 단, 매크로는 저희가 작성할 수 있습니다. 리스프의 매크로를 이용하면 언어의 강력한 힘을 이용하여 우리만의 기능을 추가 할 수 있습니다. 이 장의 뒷 부분에서 간략하게 간단한 매크로를 작성해 볼 것입니다 [p 61]. 20장에서는[p 188] 복잡한 매크로에 대해 다뤄볼 것입니다.</p>
<h2 id="짚고-넘어가기-2"><a class="header" href="#짚고-넘어가기-2">짚고 넘어가기</a></h2>
<ul>
<li>폼(form)</li>
<li>키워드(<code>:</code>)</li>
<li>전위 표기법(prefix notation)</li>
<li><code>atom</code></li>
<li><code>numberp</code></li>
<li><code>NIL</code></li>
<li><code>T</code></li>
<li><code>values</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="레슨-03-스페셜-폼과-매크로에-대한-예제"><a class="header" href="#레슨-03-스페셜-폼과-매크로에-대한-예제">레슨 03. 스페셜 폼과 매크로에 대한 예제</a></h1>
<ul>
<li><a href="https://dept-info.labri.fr/~strandh/Teaching/MTP/Common/David-Lamkins/chapter03-03.html">원문</a></li>
</ul>
<p>이제 스페셜 폼과 매크로에 대해 살펴보도록 하겠습니다. 다음 4개의 레슨들을 거쳐, 가장 기본적인 리스프 데이터 형식, 리스트를 이용하여 간단한 함수를 작성케 해주는 레파토리를 구축할 것입니다. 나머지 장에서는 더욱 복잡한 프로그램 구조와 데이터형식을 다룰 것입니다.</p>
<h2 id="setq"><a class="header" href="#setq">SETQ</a></h2>
<p>이전에, 여러분께 리스프가 심볼 폼을 평가하여 변수의 값을 받온다고 말했습니다. <code>setq</code>는 이 변수의 값을 설정하는 방법을 제공합니다:</p>
<pre><code class="language-lisp">(setq my-name &quot;David&quot;)
;;=&gt; &quot;David&quot;

my-name
;;=&gt; &quot;David&quot;

(setq a-variable 57)
;;=&gt; 57

a-variable
;;=&gt; 57

(setq a-variable :a-keyword)
;;=&gt; :A-KEYWORD
</code></pre>
<p><code>setq</code>의 첫번째 인자는 심볼입니다. 이는 평가되지 않습니다. 두번째 인자는 변수의 값으로 할당됩니다. <code>setq</code>는 마지막 인자의 값을 반환합니다.</p>
<p><code>setq</code>는 심볼 그 자체를 값으로 할당하고자 하기에 첫번째 인자를 평가하지 않습니다. 만일 <code>setq</code>가 첫번째 인자를 평가한다면, (할당될 심볼이 있어야 하기에)해당 인자의 값은 심볼이여야 합니다. <code>set</code> 폼이 그러한 일을 합니다:</p>
<pre><code class="language-lisp">(setq var-1 'var-2)
;;=&gt; VAR-2

var-1
;;=&gt; VAR-2

var-2
;;&gt;| Error: Unbound variable :TODO(pyoung)

(set var-1 99)
;;=&gt; 99

var-1
;;=&gt; VAR-2

VAR-2
;;=&gt; 99
</code></pre>
<p>첫번째 폼에서 <code>'</code>을 발견하셨나요? 이것은 다음 폼 <code>var-2</code> 가 평가되는 것을 방지합니다. 이번 레슨 후반에, <code>quote</code>[p 50]를 살펴볼때, 더욱 자세히 설명하도록 하겠습니다.</p>
<p>이번 예제에서는, 우선 <code>var-1</code>의 값을 심볼 <code>var-2</code>로 설정하였습니다. 그 후 <code>var-2</code>의 값을 확인하였고, 아무런 값도 가지지 않았다는 것을 확인하였습니다. 다음으로, (setq가 아닌) <code>set</code>을 이용하여 <code>var-1</code>의 값인 심볼 <code>var-2</code>에 값 99를 할당하였습니다.</p>
<p>사실 <code>setq</code> 폼은 심볼과 값을 번갈아 사용하여 짝수개의 인자를 취할 수 있습니다:</p>
<pre><code class="language-lisp">(setq month &quot;June&quot;
      day   8
      year  1954)
;;=&gt; 1954

month
;;=&gt; &quot;June&quot;

day
;;=&gt; 8

year
;;=&gt; 1954
</code></pre>
<p><code>setq</code>는 좌측에서 우측으로 할당을 수행하고, 맨 우측에 있는 값을 반환합니다.</p>
<h2 id="let"><a class="header" href="#let">LET</a></h2>
<p><code>let</code> 폼은 이전에 봐왔던 것보다 좀 더 복잡해 보입니다. <code>let</code>폼은 중첩된 리스트를 이용하지만, 스페셜 폼은 아니기에 특정 요소만 평가됩니다:</p>
<pre><code class="language-lisp">(let ((a 3)
      (b 4)
      (c 5))
  (* (+ a b) c))
;;=&gt; 35

a
;;&gt;| Error: Unbound variable

b
;;&gt;| Error: Unbound variable

c
;;&gt;| Error: Unbound variable
</code></pre>
<p>위에 있는 <code>let</code> 폼은 심볼 <code>a</code>, <code>b</code>, <code>c</code>의 값을 정의 후, 이를 이용하여 산술 계산을 하였습니다. 또한 이 계산의 결과가 바로 <code>let</code> 폼의 결과입니다. <code>let</code>에서 정의된 변수가 폼을 평가한 후에는 어떠한 값도 지니지 않는다는 점을 주목하시기 바랍니다.</p>
<p>대게, <code>let</code>은 다음과 같이 생겼습니다:</p>
<pre><code class="language-lisp">(let (bindings)
  forms)
</code></pre>
<p>bindings에는 임의의 수의 두개의 원소를 지닌 리스트가 있으며 (각 리스트는 심볼과 값을 지닙니다), forms에는 임의의 수의 리스프 폼이 있습니다. forms의 평가를 위해, bindings에 의해 수립된 값을 이용합니다. <code>let</code>은 마지막 폼에 의해 반환된 값(들)을 반환합니다.</p>
<p>들여쓰기는 <code>let</code>의 동작에 영향을 미치진 않지만, 적절한 들여쓰기는 가독성을 향상시킵니다. 다음 두 동일한 폼을 살펴보시기 바랍니다:</p>
<pre><code class="language-lisp">(let ((p 52.8)
      (q 35.9)
      (r (f 12.07)))
  (g 18.3)
  (f p)
  (f q)
  (g r t))

(let ((p 52.8) (q 35.9) (r (f 12.07))) (g 18.3) (f p) (f q) (g r t))
</code></pre>
<p>첫번째 경우, 들여쓰기로 어떤게 바인딩이며 어떤게 폼인지 명확하게 나타납니다. 독자가 <code>let</code> 폼의 두 부분에서 수행된 서로 다른 규칙에 대해 자세히 알지 못할지라도, 들여쓰기는 차이를 나타냅니다.</p>
<p>두번째경우, 여러분은 어디에서 바인딩이 끝나며 폼이 시작되는지 알고자 한다면, 괄호를 세어야만 할 것입니다. 더욱 안좋은 것은, 들여쓰기의 부제는 <code>let</code> 폼의 두 부분에 의해 수행되는 역활의 차이점에 대해 시각적 단서(visual cues)를 없애버립니다.</p>
<p><code>setq</code>를 이용하여 변수를 정의하고 <code>let</code> 폼에서 동일한 변수 이름을 사용한다면, <code>let</code>을 평가하는 동안 <code>let</code>에 의해 정의된 값이 (<code>setq</code>에 의해 정의된)다른 값을 대체할 것입니다:</p>
<pre><code class="language-lisp">(setq a 89)
;;=&gt; 89

a
;;=&gt; 89

(let ((a 3))
  (+ a 2))
;;=&gt; 5

a
;;=&gt; 89
</code></pre>
<p>좌에서 우로 순서대로 값의 할당이 이루어지는 <code>setq</code>와 달리, <code>let</code>은 모두 동일한 시간에 변수를 바인드합니다.</p>
<pre><code class="language-lisp">(setq w 77)
;;=&gt; 77

(let ((w 8)
      (x w))
  (+ w x))
;;=&gt; 85
</code></pre>
<p><code>let</code>은 <code>w</code>를 8로 <code>x</code>는 w로 바인드 하였습니다. 동일한 시각에 이러한 바인딩이 발생하였으므로 <code>w</code>는 여전히 값 77을 지니게 됩니다.</p>
<p>리스프는 순서대로 바인딩을 수행하는 <code>let*</code>이라는 <code>let</code>의 변종을 지녔습니다.</p>
<pre><code class="language-lisp">(setq u 37)
;;=&gt; 37

(let* ((v 4)
       (u v))
  (+ u v))
;;=&gt; 8
</code></pre>
<h2 id="cond"><a class="header" href="#cond">COND</a></h2>
<p><code>cond</code> 매크로는 조건적으로 리스프 폼을 평가하도록 합니다. <code>let</code>처럼, <code>cond</code>는 폼의 다양한 부분을 구분짓기 위해 괄호를 이용합니다. 이 예제를 살펴보시기 바랍니다:</p>
<pre><code class="language-lisp">(let ((a 1)
      (b 2)
      (c 1)
      (d 1))
  (cond ((eql a b) 1)
        ((eql a c) &quot;First form&quot; 2)
        ((eql a d) 3)))
;;=&gt; 2
</code></pre>
<p>위에 정의된 <code>cond</code> 폼에서 3개의 절을 정의하였습니다. 각 절은 테스트 폼으로 시작하는 리스트이며 원하는 만큼의 바디(body) 폼이 뒷따라 나옵니다. 바디 폼은 테스트가 성공일시 실행되는 코드 입니다. 순차적으로 절이 선택됩니다 - 하나의 테스트가 성공하면 그에 대응하는 바디 폼이 평가되고 그 바디 폼의 마지막 값이 <code>cond</code> 폼의 값이 됩니다.</p>
<p><code>cond</code>는 여러 절을 다룰 수 있기에, 스페셜 폼 <code>if</code>에 비해 범용적입니다.</p>
<p>이제 예제에서 어떤일이 수행되는지 살펴보도록 하겠습니다. 두 인자가 동일하거나, 동일한 숫자면 <code>eql</code> 은 <code>T</code>를 반환합니다(17장[p 174]에서 다루게될 미묘한 다름이 있긴 합니다). 3개의 테스트중 두개만 실행되었습니다. 첫번째 <code>(eql a b)</code>는 <code>NIL</code>을 반환합니다. 그러므로, 1을 포함하는 절은 넘어갑니다. 두번째 절은 <code>(eql a c)</code>를 테스트하며 이는 참입니다. 이 테스트가 <code>NIL</code>이 아닌 값을 반환하기에, 절의 나머지 부분이 평가가 되어, 마지막 폼의 값이 <code>cond</code>의 값으로 반환된 다음, 최종적으로 <code>let</code>의 반환값으로써 반환됩니다. 세번째 절은 이미 이전 절이 선택되었기에 평가되지 않습니다 - 절들은 순서대로 선택됩니다.</p>
<p>관습적으로 <code>cond</code>의 마지막 절의 테스트 폼으로 <code>T</code>를 사용합니다. 이는 다른 절들이 모두 테스트에 실패를 하면 마지막 절의 바디 폼이 평가된다는 것을 보증합니다. 기본 값을 반환하거나 기타 다른 적절한 작업을 수행하기 위해 이 마지막 절을 활용할 수 있습니다. 여기 예제가 있습니다:</p>
<pre><code class="language-lisp">(let ((a 32))
  (cond ((eql a 13)
         &quot;An unlucky number&quot;)
        ((eql a 99)
         &quot;A lucky number&quot;)
        (t
         &quot;Nothing special about this number&quot;)))
;;=&gt; &quot;Nothing special about this number&quot;
</code></pre>
<h2 id="quote"><a class="header" href="#quote">QUOTE</a></h2>
<p>가끔씩 리스프의 평가 규칙을 적용시키지 않고 싶을 때가 있을것입니다.. 이러한 예 중 하나를 꼽자면, 함수 호출의 인자로써 심볼의 값보다 심볼 그 자체를 쓰고 싶을 때입니다:</p>
<pre><code class="language-lisp">(setq a 97)
;;=&gt; 97

a
;;=&gt; 97

(setq b 23)
;;=&gt; 23

(setq a b)
;;=&gt; 23

a
;;=&gt; 23

(setq a (quote b))
;;=&gt; B

a
;;=&gt; B
</code></pre>
<p>차이점은 <code>(setq a b)</code>에서 사용된 <code>b</code>의 <em>값</em> 과 <code>(setq a (quote b))</code>에서의 <em>심볼</em> <code>b</code>입니다.</p>
<p><code>quote</code> 폼은 매우 자주 사용되며, 리스프는 약칭 표기를 제공합니다:</p>
<pre><code class="language-txt">(QUOTE form) == 'form
</code></pre>
<p>리스프는 리더 매크로를 통해 <code>'</code>와 <code>quote</code>를 동일하게 처리합니다. 레슨 12 [p 82]에서 어떻게 여러분만의 리더 매크로를 정의할 수 있는지 간략하게 살펴볼 것입니다.</p>
<h2 id="짚고-넘어가기-3"><a class="header" href="#짚고-넘어가기-3">짚고 넘어가기</a></h2>
<ul>
<li><code>setq</code></li>
<li><code>let</code></li>
<li><code>cond</code></li>
<li><code>'</code>, <code>quote</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="레슨-04-조립과-분해"><a class="header" href="#레슨-04-조립과-분해">레슨 04. 조립과 분해</a></h1>
<ul>
<li><a href="https://dept-info.labri.fr/~strandh/Teaching/MTP/Common/David-Lamkins/chapter03-04.html">원문</a></li>
</ul>
<h2 id="cons"><a class="header" href="#cons">CONS</a></h2>
<p><code>cons</code>는 리스트의 가장 기본적인 구성 요소입니다. 이는 함수므로 이의 인자들을 평가합니다. 리스트를 만들때에는 <code>cons</code>의 두번째 인자로 <code>리스트</code> 혹은 <code>NIL</code>이 들어올것입니다.</p>
<pre><code class="language-lisp">(cons 1 nil)
;;=&gt; (1)

(cons 2 (cons 1 nil))
;;=&gt; (2 1)

(cons 3 (cons 2 (cons 1 nil)))
;;=&gt; (3 2 1)
</code></pre>
<p><code>cons</code>는 새로운 항목을 리스트의 시작 부분에 추가합니다. 비어있는 리스트 <code>( )</code> 는 <code>NIL</code>과 동일하며,</p>
<pre><code class="language-txt">( ) ==  NIL
</code></pre>
<p>따라서 이렇게 작성할 수 있습니다:</p>
<pre><code class="language-lisp">(cons 1 ())
;;=&gt; (1)

(cons 2 (cons 1 ()))
;;=&gt; (2 1)

(cons 3 (cons 2 (cons 1 ())))
;;=&gt; (3 2 1)
</code></pre>
<p>혼란스럽게 느껴진다면, 맞습니다, <code>NIL</code>에는 뭔가 특별한 능력이 있습니다. <code>NIL</code>은 키워드는 아니지만 자기 자신을 상수 값으로 가지는 리스프의 두개의 심볼 중 하나입니다. 또 다른 심볼은 <code>T</code>입니다.</p>
<p><code>( ) == NIL</code>이란 것과 <code>NIL</code>이 스스로 평가된다는 것을 종합해보면, 이는 <code>(quote ())</code>를 <code>()</code>로 쓸 수 있다는 것을 의미합니다. 그렇지 않았다면, 리스프는 빈 리스트를 처리하기 위해 평가 규칙에 예외를 추가해야 했을 것입니다.</p>
<h2 id="list"><a class="header" href="#list">LIST</a></h2>
<p>아마 여러분이 눈치챗다면, 중첩된 <code>cons</code> 폼으로도 리스트가 만들어질 수 있다는 것은 조금 지루할 수 도 있습니다. <code>list</code> 폼은 좀더 명료한 방법으로 동일한 일을 수행합니다:</p>
<pre><code class="language-lisp">(list 1 2 3)
;;=&gt; (1 2 3)
</code></pre>
<p><code>list</code>는 여러 인자를 취할 수 있습니다. <code>list</code>는 함수이기에, 이는 인자를 평가합니다:</p>
<pre><code class="language-lisp">(list 1 2 :hello &quot;there&quot; 3)
;;=&gt; (1 2 :HELLO &quot;there&quot; 3)

(let ((a :this)
      (b :and)
      (c :that))
  (list a 1 b c 2))
;;=&gt; (:THIS 1 :AND :THAT 2)
</code></pre>
<h2 id="first와-rest"><a class="header" href="#first와-rest"><strong>FIRST</strong>와 <strong>REST</strong></a></h2>
<p>리스트가 (첫번째와 나머지) 두 부분으로 만들어졌다고 가정한다면, 여러분은 <code>first</code>와 <code>rest</code> 두 연산자를 이용하여 리스트의 개별 원소들을 얻을 수 있습니다:</p>
<pre><code class="language-lisp">(setq my-list (quote (1 2 3 4 5)))
;;=&gt; (1 2 3 4 5)

(first my-list)
;;=&gt; 1

(rest my-list)
;;=&gt; (2 3 4 5)

(first (rest my-list))
;;=&gt; 2

(rest (rest my-list))
;;=&gt; (3 4 5)

(first (rest (rest my-list)))
;;=&gt; 3

(rest (rest (rest my-list)))
;;=&gt; (4 5)

(first (rest (rest (rest my-list))))
;;=&gt; 4
</code></pre>
<p><code>first</code>와 <code>rest</code> 함수를 이리저리 엮는 것은 분명 지루한 작업일 것입니다. 또, 이러한 접근 법은 프로그램에서 특정 요소만을 선택하고자 할때나 혹은 리스트의 길이가 무한일때 잘 먹히지 않을 것입니다. 4장[p 84] 에서 재귀 함수를 정의할때 이러한 문제를 어떻게 해결하는지 살펴볼 것입니다. 나중에 13장에서 [p 150], 리스프가 제공하는 리스트 혹은 시퀀스 속 요소를 선택할 수 있는 함수들을 살펴 볼 것입니다</p>
<p><code>first</code>와 <code>rest</code>는 꽤 최근 동안 활약해온 <code>car</code>와 <code>cdr</code> 함수의 이름을 바꾸어 리스프에 추가된 것입니다. 초기 리스프 구현체 중 하나에서 <code>car</code>와 <code>cdr</code>의 이름이 유례됬고, 이 이름에 기반한 구현체가 이미 오래전에 바뀌었음에도 불구하고 수십년간 고수되었습니다</p>
<h2 id="짚고-넘어가기-4"><a class="header" href="#짚고-넘어가기-4">짚고 넘어가기</a></h2>
<ul>
<li><code>cons</code></li>
<li><code>list</code></li>
<li><code>first</code></li>
<li><code>rest</code></li>
<li><code>car</code></li>
<li><code>cdr</code></li>
<li><code>nil</code> , <code>( )</code></li>
<li><code>T</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="레슨-05-네이밍과-아이덴티티"><a class="header" href="#레슨-05-네이밍과-아이덴티티">레슨 05. 네이밍과 아이덴티티</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="레슨-06-바인딩-vs-할당"><a class="header" href="#레슨-06-바인딩-vs-할당">레슨 06. 바인딩 vs 할당</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="레슨-07-필수---함수-정의"><a class="header" href="#레슨-07-필수---함수-정의">레슨 07. 필수 - 함수 정의</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="레슨-08-필수---매크로-정의"><a class="header" href="#레슨-08-필수---매크로-정의">레슨 08. 필수 - 매크로 정의</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="레슨-09-필수---다중-값"><a class="header" href="#레슨-09-필수---다중-값">레슨 09. 필수 - 다중 값</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="레슨-10-프리뷰---다른-데이터-타입"><a class="header" href="#레슨-10-프리뷰---다른-데이터-타입">레슨 10. 프리뷰 - 다른 데이터 타입</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="레슨-11-필수---입력과-출력"><a class="header" href="#레슨-11-필수---입력과-출력">레슨 11. 필수 - 입력과 출력</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="레슨-12-필수---리더-매크로"><a class="header" href="#레슨-12-필수---리더-매크로">레슨 12. 필수 - 리더 매크로</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
